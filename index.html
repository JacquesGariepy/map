<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Planificateur d'Itinéraire IA - Configuration Avancée</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS / MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin=""/>

    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Leaflet JS / MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin=""></script>

    <style>
        /* --- Variables de Couleurs et Design --- */
        :root {
            --font-main: 'Inter', sans-serif;
            --bg-body: #F9FAFB; /* Gris très clair */
            --bg-sidebar: #FFFFFF;
            --bg-input: #FFFFFF;
            --bg-hover-light: #F3F4F6; /* Gris clair pour hover */
            --bg-selected-light: #D1FAE5; /* Vert très clair pour sélection */
            --bg-config-panel: rgba(255, 255, 255, 0.98); /* Fond légèrement transparent */

            --text-primary: #1F2937; /* Gris très foncé */
            --text-secondary: #6B7280; /* Gris moyen */
            --text-placeholder: #9CA3AF; /* Gris clair */
            --text-white: #FFFFFF;

            --border-color: #E5E7EB; /* Gris clair pour bordures */
            --border-focus: var(--color-primary);
            --border-selected: var(--color-secondary);

            --color-primary: #3B82F6; /* Bleu primaire */
            --color-primary-dark: #2563EB; /* Bleu primaire foncé (hover) */
            --color-secondary: #10B981; /* Vert secondaire (succès, sélection) */
            --color-secondary-dark: #059669; /* Vert secondaire foncé (hover) */
            --color-danger: #EF4444; /* Rouge pour erreurs */
            --color-danger-light: #FEE2E2; /* Fond rouge clair pour erreurs */
            --color-info: #60A5FA; /* Bleu clair pour info */
            --color-warning: #F59E0B; /* Orange pour avertissements */
            --color-warning-light: #FEF3C7; /* Fond orange clair */

            --border-radius: 6px; /* Rayon pour coins arrondis */
            --box-shadow-light: 0 1px 3px 0 rgba(0, 0, 0, 0.07), 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --box-shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --box-shadow-large: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);

            --spinner-size: 1.2em; /* Taille du spinner */
        }

        /* --- Styles de Base --- */
        *, *::before, *::after { box-sizing: border-box; }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: var(--font-main);
            background-color: var(--bg-body);
            color: var(--text-primary);
            font-size: 16px;
            line-height: 1.5;
            overflow: hidden; /* Empêche scroll global */
        }

        #container {
            display: flex;
            height: 100%;
        }

        /* --- Sidebar --- */
        #sidebar {
            width: 450px; /* Légèrement plus large */
            position: relative; /* Pour positionner le panneau config */
            padding: 20px;
            background-color: var(--bg-sidebar);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            box-shadow: var(--box-shadow-light);
            transition: width 0.3s ease; /* Pour future responsivité */
            z-index: 10; /* Pour être au-dessus de la carte mais sous le panneau config */
        }

        #map {
            flex-grow: 1;
            height: 100%;
            background-color: #E5E7EB;
        }

        h3 {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 25px;
            margin-bottom: 15px;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        /* --- Formulaires --- */
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        input[type="text"], input[type="password"], input[type="number"], select, textarea {
            display: block;
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 15px;
            font-size: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-input);
            color: var(--text-primary);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="text"]::placeholder,
        input[type="password"]::placeholder,
        textarea::placeholder {
            color: var(--text-placeholder);
        }
        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Ombre focus bleue */
        }
        input[type="color"] {
            height: 40px;
            padding: 5px;
            cursor: pointer;
            width: 60px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
        }
        textarea {
            min-height: 90px;
            resize: vertical;
        }
        select {
            appearance: none; /* Style custom flèche si désiré via background-image */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1.25em 1.25em;
            padding-right: 2.5rem;
        }

        /* --- Boutons --- */
        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px; /* Espace entre icône et texte */
            padding: 10px 18px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            width: 100%;
            margin-bottom: 10px;
        }
        button i {
            font-size: 0.9em;
        }

        #planRouteBtn {
            background-color: var(--color-primary);
            color: var(--text-white);
        }
        #planRouteBtn:hover:not(:disabled) {
            background-color: var(--color-primary-dark);
            box-shadow: var(--box-shadow-light);
        }

        #calculateSelectedRouteBtn {
            background-color: var(--color-secondary);
            color: var(--text-white);
            margin-top: 15px;
        }
        #calculateSelectedRouteBtn:hover:not(:disabled) {
            background-color: var(--color-secondary-dark);
            box-shadow: var(--box-shadow-light);
        }

        #loadMoreBtn {
            background-color: var(--text-secondary);
            color: var(--text-white);
            font-size: 0.9rem;
            padding: 8px 15px;
            margin-top: 10px;
            width: auto; /* Ne prend pas toute la largeur */
        }
        #loadMoreBtn:hover:not(:disabled) {
            background-color: var(--text-primary);
        }

        /* Bouton Settings */
        #toggleConfigBtn {
            position: absolute; /* Par rapport à #sidebar */
            bottom: 15px;
            right: 15px;
            width: 45px; /* Carré */
            height: 45px;
            padding: 0;
            border-radius: 50%;
            background-color: var(--text-secondary);
            color: var(--text-white);
            box-shadow: var(--box-shadow-medium);
            z-index: 15;
        }
        #toggleConfigBtn:hover {
            background-color: var(--text-primary);
        }
        #toggleConfigBtn i {
            font-size: 1.2em;
        }

        button:disabled {
            background-color: #D1D5DB !important; /* Gris clair désactivé */
            color: #9CA3AF !important;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
        }
        button .spinner {
            display: none;
        }
        button.loading .spinner {
            display: inline-block;
            width: var(--spinner-size);
            height: var(--spinner-size);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: var(--text-white);
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Panneaux POI et Résultats --- */
        #poiPanel,
        #resultsPanel {
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
            margin-top: 25px;
        }

        /* --- Filtres POI --- */
        #poiFilters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 15px;
            margin-bottom: 15px;
        }
        #poiFilters label {
            display: inline-flex;
            align-items: center;
            margin-right: 0;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-secondary);
        }
        #poiFilters input[type="checkbox"] {
            width: 1em;
            height: 1em;
            margin-right: 6px;
            vertical-align: middle;
            accent-color: var(--color-primary);
        }
        #poiFilters label:hover {
            color: var(--text-primary);
        }

        #showPoiToggle {
            margin-top: 15px;
            margin-bottom: 10px;
        }
        #showPoiToggle label {
            font-size: 0.9rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            color: var(--text-secondary);
        }
        #showPoiToggle input {
            width: auto;
            margin-right: 6px;
            accent-color: var(--color-primary);
        }

        /* --- Liste POI --- */
        #poiList {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-top: 10px;
            padding: 8px;
            background-color: var(--bg-input);
        }
        .poi-item {
            margin-bottom: 6px;
            cursor: pointer;
            padding: 10px 12px;
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            font-size: 0.95rem;
            background-color: var(--bg-input);
            transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            line-height: 1.3;
        }
        .poi-item:hover {
            background-color: var(--bg-hover-light);
        }
        .poi-item.selected {
            background-color: var(--bg-selected-light);
            border-color: var(--border-selected);
            font-weight: 500;
            color: var(--color-secondary-dark);
        }

        /* --- Compteur POI --- */
        #poiCount {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-left: 5px;
        }

        /* --- Panneau Résultats --- */
        #routeSummary {
            margin-top: 10px;
            font-size: 0.95rem;
            line-height: 1.6;
        }
        #routeInstructions {
            margin-top: 15px;
        }
        #routeInstructions h4 {
            margin-bottom: 10px;
            font-size: 1rem;
        }
        #routeInstructions ol {
            padding-left: 25px;
            font-size: 0.95rem;
            margin: 0;
            list-style: decimal;
        }
        #routeInstructions li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        #routeInstructions li strong {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* --- Messages Status --- */
        .error,
        .success,
        .info,
        .loading,
        .warning {
            padding: 10px 12px;
            border-radius: var(--border-radius);
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 0.95rem;
            border: 1px solid transparent;
        }
        .error {
            color: #991B1B;
            background-color: var(--color-danger-light);
            border-color: #FCA5A5;
            font-weight: 500;
        }
        .success {
            color: #065F46;
            background-color: var(--bg-selected-light);
            border-color: #6EE7B7;
            font-weight: 500;
        }
        .info {
            color: #1E40AF;
            background-color: #DBEAFE;
            border-color: #93C5FD;
            font-weight: normal;
        }
        .warning {
            color: #92400E;
            background-color: var(--color-warning-light);
            border-color: #FCD34D;
            font-weight: 500;
        }
        .loading {
            color: var(--text-secondary);
            font-style: italic;
            background-color: transparent;
            border: none;
            padding: 5px 0;
        }

        /* --- Panneau Configuration --- */
        #configPanel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-config-panel);
            backdrop-filter: blur(3px);
            padding: 20px;
            border-right: 1px solid var(--border-color);
            box-shadow: var(--box-shadow-large);
            overflow-y: auto;
            z-index: 20;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
        }
        #configPanel.visible {
            transform: translateX(0);
        }
        #configPanel h4 {
            margin-top: 0;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #closeConfigBtn {
            width: auto;
            padding: 5px 10px;
            font-size: 0.9rem;
            background-color: var(--bg-hover-light);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            margin: 0;
        }
        #closeConfigBtn:hover {
            background-color: var(--border-color);
            color: var(--text-primary);
        }
        #closeConfigBtn i {
            margin-right: 5px;
        }

        #configPanel label {
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        #configPanel input[type="text"],
        #configPanel input[type="password"],
        #configPanel input[type="number"] {
            margin-bottom: 12px;
            padding: 8px 10px;
            font-size: 0.95rem;
        }
        #configPanel .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }
        #configPanel .input-group > div {
            flex: 1;
        }
        #configPanel .input-group label {
            display: block;
        }
        #configPanel .input-group input {
            margin-bottom: 0;
        }

        #saveConfigBtn {
            background-color: var(--color-primary);
            color: var(--text-white);
            margin-top: 20px;
        }
        #saveConfigBtn:hover {
            background-color: var(--color-primary-dark);
        }
        #configStatus {
            margin-top: 15px;
        }

        /* --- Styles Leaflet --- */
        .leaflet-container {
            font-family: var(--font-main);
            font-size: 14px;
        }
        .leaflet-popup-content-wrapper {
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-medium);
            background-color: var(--bg-sidebar);
        }
        .leaflet-popup-content {
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
            margin: 12px 15px;
            max-width: 250px;
            word-wrap: break-word;
        }
        .leaflet-popup-content b {
            font-weight: 600;
        }
        .leaflet-popup-content small {
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: block;
            margin-top: 4px;
        }
        .leaflet-popup-close-button {
            color: var(--text-secondary) !important;
            padding: 8px 8px 0 0 !important;
        }

        /* Marker Cluster */
        /* Personnalisation possible */
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h3>Planificateur d'Itinéraire IA</h3>

            <!-- ### NOUVEAU: Bouton "Me Localiser" -->
            <button id="locateMeBtn" style="background-color:#4ade80; color:#fff; margin-bottom:10px;">
                <i class="fa-solid fa-location-arrow"></i>
                <span>Me Localiser</span>
            </button>

            <label for="start">Départ :</label>
            <input type="text" id="start" placeholder="Adresse ou lieu de départ">

            <label for="end">Arrivée :</label>
            <input type="text" id="end" placeholder="Adresse ou lieu d'arrivée">

            <label for="interests">Décrivez vos intérêts pour ce voyage :</label>
            <textarea id="interests" placeholder="Ex: Paysages magnifiques, villages pittoresques, éviter les autoroutes, etc."></textarea>

            <label for="profile">Profil de déplacement :</label>
            <select id="profile">
                <option value="driving-car" selected>Voiture</option>
                <option value="driving-hgv">Camion / Poids Lourd</option>
                <option value="cycling-regular">Vélo</option>
                <option value="foot-walking">Marche</option>
            </select>

            <label for="routePref">Préférence d'itinéraire (si applicable) :</label>
            <select id="routePref">
                <option value="FASTEST" selected>Le plus rapide</option>
                <option value="SHORTEST">Le plus court</option>
                <option value="AVOID_HIGHWAYS">Éviter les autoroutes</option>
                <option value="AVOID_TOLLS">Éviter les péages</option>
            </select>

            <!-- ### NOUVEAU: Choix "Nombre de Jours" pour la planification -->
            <label for="tripDays">Plan sur plusieurs jours :</label>
            <input type="number" id="tripDays" min="1" max="30" step="1" value="1" />

            <button id="planRouteBtn">
                <i class="fa-solid fa-search"></i>
                <span class="button-text">1. Trouver POI Pertinents</span>
                <span class="spinner"></span>
            </button>

            <div id="poiPanel">
                <h4>Points d'intérêt <span id="poiCount"></span></h4>
                <div id="poiFilters">
                    <label title="Points de vue, panoramas, paysages">
                        <input type="checkbox" class="poi-filter" value="viewpoint,panorama,paysage,scenic" checked>
                        Vues & Paysages
                    </label>
                    <label title="Parcs, jardins, réserves naturelles">
                        <input type="checkbox" class="poi-filter" value="park,parc,garden,jardin,reserve,réserve,natural" checked>
                        Parcs/Nature
                    </label>
                    <label title="Magasins fermiers, marchés, produits locaux">
                        <input type="checkbox" class="poi-filter" value="farm,ferme,market,marché,local,terroir,produit,shop=farm,amenity=marketplace" checked>
                        Terroir/Marchés
                    </label>
                    <label title="Observation oiseaux, refuges animaliers">
                        <input type="checkbox" class="poi-filter" value="bird,oiseau,hide,observatoire,wildlife" checked>
                        Oiseaux/Faune
                    </label>
                    <label title="Sites historiques, châteaux, ruines, musées">
                        <input type="checkbox" class="poi-filter" value="historic,castle,château,ruin,ruine,monument,museum,musée" checked>
                        Histoire/Culture
                    </label>
                    <label title="Lacs, rivières, plages, cascades">
                        <input type="checkbox" class="poi-filter" value="water,beach,river,lake,waterfall,eau,plage,rivière,lac,cascade" checked>
                        Eau/Plages
                    </label>
                    <label title="Villages, lieux pittoresques">
                        <input type="checkbox" class="poi-filter" value="village,hamlet,pittoresque" checked>
                        Villages
                    </label>
                </div>
                <div id="showPoiToggle">
                    <label>
                        <input type="checkbox" id="togglePoiLayer" checked>
                        Afficher POI sur la carte
                    </label>
                </div>
                <div id="poiList" class="loading" aria-live="polite">Prêt à chercher des POI.</div>
                <button id="loadMoreBtn" style="display: none;">
                    <i class="fa-solid fa-chevron-down"></i> Afficher plus
                </button>
            </div>

            <button id="calculateSelectedRouteBtn" style="display: none;">
                <i class="fa-solid fa-route"></i>
                <span class="button-text">2. Calculer Itinéraire via Sélection</span>
                <span class="spinner"></span>
            </button>

            <div id="resultsPanel">
                <h4>Itinéraire et Résumé</h4>
                <div id="routeSummary" class="loading" aria-live="polite">Prêt à calculer l'itinéraire.</div>
                <div id="routeInstructions"></div>

                <!-- ### NOUVEAU: Bouton Export GPX -->
                <button id="exportGpxBtn" style="display: none; background-color:#444; color:#fff;">
                    <i class="fa-solid fa-download"></i> Export GPX
                </button>
            </div>

            <button id="toggleConfigBtn" title="Ouvrir les Paramètres">
                <i class="fa-solid fa-gear"></i>
            </button>

            <div id="configPanel">
                <h4>
                    Paramètres de l'Application
                    <button id="closeConfigBtn"><i class="fa-solid fa-times"></i> Fermer</button>
                </h4>

                <p style="font-size: 0.8rem; color: var(--color-danger); margin-bottom: 15px; border: 1px solid var(--color-danger); padding: 8px; border-radius: var(--border-radius); background-color: var(--color-danger-light);">
                    <i class="fa-solid fa-triangle-exclamation"></i> <strong>ATTENTION:</strong> Les clés API sont stockées localement dans votre navigateur (localStorage). Ne partagez pas cet ordinateur et soyez conscient que cette méthode n'est <strong>PAS SÉCURISÉE</strong> pour un usage public ou en production.
                </p>

                <label for="configOrsApiKey">Clé API OpenRouteService :</label>
                <input type="password" id="configOrsApiKey" placeholder="Entrez votre clé ORS">

                <label for="configGeminiApiKey">Clé API Google Gemini :</label>
                <input type="password" id="configGeminiApiKey" placeholder="Entrez votre clé Gemini">

                <!-- ### NOUVEAU: Clé API OpenWeatherMap -->
                <label for="configWeatherApiKey">Clé API OpenWeatherMap :</label>
                <input type="password" id="configWeatherApiKey" placeholder="Entrez votre clé OpenWeatherMap">

                <div class="input-group">
                    <div>
                        <label for="configMapCenterLat">Centre Carte Lat Défaut :</label>
                        <input type="number" id="configMapCenterLat" step="0.0001">
                    </div>
                    <div>
                        <label for="configMapCenterLon">Centre Carte Lon Défaut :</label>
                        <input type="number" id="configMapCenterLon" step="0.0001">
                    </div>
                </div>

                <label for="configMapZoom">Zoom Carte Défaut :</label>
                <input type="number" id="configMapZoom" min="1" max="19" step="1">

                <label for="configRouteColor">Couleur Itinéraire :</label>
                <input type="color" id="configRouteColor">

                <label for="configBboxMargin">Marge Zone Recherche (%):</label>
                <input type="number" id="configBboxMargin" min="0" max="100" step="1" title="Pourcentage (0-100) ajouté autour des points départ/arrivée pour chercher les POI. 15% = 0.15 degrés env.">

                <label for="configPoiListLimit">Limite POI par Page (Liste) :</label>
                <input type="number" id="configPoiListLimit" min="5" max="200" step="5">

                <label for="configOverpassTimeout">Timeout Overpass (secondes) :</label>
                <input type="number" id="configOverpassTimeout" min="10" max="180" step="5">

                <label for="configOverpassEndpoint">Endpoint API Overpass :</label>
                <input type="text" id="configOverpassEndpoint" placeholder="URL de l'instance Overpass">

                <button id="saveConfigBtn">
                    <i class="fa-solid fa-save"></i> Enregistrer les Paramètres
                </button>
                <div id="configStatus"></div>
            </div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        // --- Configuration Globale (sera écrasée par localStorage si présent) ---
        let ORS_API_KEY = '';
        let GEMINI_API_KEY = '';
        let GEMINI_API_URL = '';
        // ### NOUVEAU: Ajout pour la météo
        let WEATHER_API_KEY = ''; 
        let WEATHER_API_URL = 'https://api.openweathermap.org/data/2.5/weather';

        let MAP_DEFAULT_CENTER = [48.8566, 2.3522]; // Paris, FR
        let MAP_DEFAULT_ZOOM = 6;
        let BOUNDING_BOX_MARGIN_PERCENT = 15;
        let POI_LIST_LIMIT = 30;
        let OVERPASS_TIMEOUT = 35;
        let OVERPASS_API_ENDPOINT = 'https://overpass-api.de/api/interpreter';
        let ROUTE_COLOR = '#3B82F6';

        // Variable calculée
        let BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;

        // --- Variables Globales (état de l'application) ---
        let map;
        let routeLayer = null;
        let fullPoiList = [];
        let displayedPoiCount = 0;
        let selectedPois = [];
        let poiMarkerClusterGroup = null;
        let currentFilteredPoiList = [];
        let poiMarkers = [];

        // ### NOUVEAU: Gestion multijours
        let tripDaysCount = 1;

        // --- Icônes Leaflet ---
        const defaultIcon = new L.Icon.Default();
        const selectedIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        // --- Initialisation Leaflet & MarkerCluster ---
        try {
            map = L.map('map');
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors'
            }).addTo(map);
            poiMarkerClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 60
            });
        } catch (e) {
            console.error("Erreur critique initialisation Leaflet:", e);
            alert("Erreur critique: Impossible d'initialiser la carte Leaflet.");
        }

        // --- Références DOM ---
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        const interestsInput = document.getElementById('interests');
        const profileSelect = document.getElementById('profile');
        const routePrefSelect = document.getElementById('routePref');
        const planBtn = document.getElementById('planRouteBtn');
        const calculateSelectedRouteBtn = document.getElementById('calculateSelectedRouteBtn');
        const poiPanel = document.getElementById('poiPanel');
        const poiListDiv = document.getElementById('poiList');
        const poiCountSpan = document.getElementById('poiCount');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        const poiFilterCheckboxes = document.querySelectorAll('.poi-filter');
        const togglePoiLayerCheckbox = document.getElementById('togglePoiLayer');
        const summaryDiv = document.getElementById('routeSummary');
        const instructionsDiv = document.getElementById('routeInstructions');
        const toggleConfigBtn = document.getElementById('toggleConfigBtn');
        const configPanel = document.getElementById('configPanel');
        const closeConfigBtn = document.getElementById('closeConfigBtn');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const configStatus = document.getElementById('configStatus');
        const configOrsApiKeyInput = document.getElementById('configOrsApiKey');
        const configGeminiApiKeyInput = document.getElementById('configGeminiApiKey');
        // ### NOUVEAU:
        const configWeatherApiKeyInput = document.getElementById('configWeatherApiKey');

        const configMapCenterLatInput = document.getElementById('configMapCenterLat');
        const configMapCenterLonInput = document.getElementById('configMapCenterLon');
        const configMapZoomInput = document.getElementById('configMapZoom');
        const configRouteColorInput = document.getElementById('configRouteColor');
        const configBboxMarginInput = document.getElementById('configBboxMargin');
        const configPoiListLimitInput = document.getElementById('configPoiListLimit');
        const configOverpassTimeoutInput = document.getElementById('configOverpassTimeout');
        const configOverpassEndpointInput = document.getElementById('configOverpassEndpoint');
        // ### NOUVEAU:
        const locateMeBtn = document.getElementById('locateMeBtn');
        const tripDaysInput = document.getElementById('tripDays');
        const exportGpxBtn = document.getElementById('exportGpxBtn');

        // --- Écouteurs d'Événements ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();

            if (map) {
                map.setView(MAP_DEFAULT_CENTER, MAP_DEFAULT_ZOOM);
                if (togglePoiLayerCheckbox && togglePoiLayerCheckbox.checked) {
                    map.addLayer(poiMarkerClusterGroup);
                }
            }

            if (locateMeBtn) locateMeBtn.addEventListener('click', handleLocateMe);
            if (planBtn) planBtn.addEventListener('click', handlePlanning);
            if (calculateSelectedRouteBtn) calculateSelectedRouteBtn.addEventListener('click', handleRouteCalculationFinal);
            if (loadMoreBtn) loadMoreBtn.addEventListener('click', () => displayMorePois());
            if (togglePoiLayerCheckbox) togglePoiLayerCheckbox.addEventListener('change', togglePoiLayerVisibility);
            poiFilterCheckboxes.forEach(checkbox => checkbox.addEventListener('change', applyPoiFilters));
            if (toggleConfigBtn) toggleConfigBtn.addEventListener('click', toggleConfigPanel);
            if (closeConfigBtn) closeConfigBtn.addEventListener('click', toggleConfigPanel);
            if (saveConfigBtn) saveConfigBtn.addEventListener('click', saveSettings);
            if (tripDaysInput) tripDaysInput.addEventListener('change', (e) => {
                tripDaysCount = parseInt(e.target.value, 10) || 1;
            });
            if (exportGpxBtn) exportGpxBtn.addEventListener('click', exportGpx);

            clearPreviousResults();
        });

        // ########################################################################
        // ### GESTION DES PARAMÈTRES (LocalStorage)
        // ########################################################################
        function loadSettings() {
            try {
                ORS_API_KEY = localStorage.getItem('orsApiKey') || '';
                GEMINI_API_KEY = localStorage.getItem('geminiApiKey') || '';
                WEATHER_API_KEY = localStorage.getItem('weatherApiKey') || ''; // ### NOUVEAU

                const savedCenterLat = localStorage.getItem('mapCenterLat');
                const savedCenterLon = localStorage.getItem('mapCenterLon');
                MAP_DEFAULT_CENTER = (savedCenterLat && savedCenterLon) ? [parseFloat(savedCenterLat), parseFloat(savedCenterLon)] : MAP_DEFAULT_CENTER;

                MAP_DEFAULT_ZOOM = parseInt(localStorage.getItem('mapZoom') || MAP_DEFAULT_ZOOM, 10);
                BOUNDING_BOX_MARGIN_PERCENT = parseInt(localStorage.getItem('bboxMarginPercent') || BOUNDING_BOX_MARGIN_PERCENT, 10);
                POI_LIST_LIMIT = parseInt(localStorage.getItem('poiListLimit') || POI_LIST_LIMIT, 10);
                OVERPASS_TIMEOUT = parseInt(localStorage.getItem('overpassTimeout') || OVERPASS_TIMEOUT, 10);
                OVERPASS_API_ENDPOINT = localStorage.getItem('overpassEndpoint') || OVERPASS_API_ENDPOINT;
                ROUTE_COLOR = localStorage.getItem('routeColor') || ROUTE_COLOR;

                BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;

                if (GEMINI_API_KEY) {
                    GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                } else {
                    GEMINI_API_URL = '';
                }

                if (configOrsApiKeyInput) configOrsApiKeyInput.value = ORS_API_KEY;
                if (configGeminiApiKeyInput) configGeminiApiKeyInput.value = GEMINI_API_KEY;
                if (configWeatherApiKeyInput) configWeatherApiKeyInput.value = WEATHER_API_KEY; // ### NOUVEAU
                if (configMapCenterLatInput) configMapCenterLatInput.value = MAP_DEFAULT_CENTER[0];
                if (configMapCenterLonInput) configMapCenterLonInput.value = MAP_DEFAULT_CENTER[1];
                if (configMapZoomInput) configMapZoomInput.value = MAP_DEFAULT_ZOOM;
                if (configBboxMarginInput) configBboxMarginInput.value = BOUNDING_BOX_MARGIN_PERCENT;
                if (configPoiListLimitInput) configPoiListLimitInput.value = POI_LIST_LIMIT;
                if (configOverpassTimeoutInput) configOverpassTimeoutInput.value = OVERPASS_TIMEOUT;
                if (configOverpassEndpointInput) configOverpassEndpointInput.value = OVERPASS_API_ENDPOINT;
                if (configRouteColorInput) configRouteColorInput.value = ROUTE_COLOR;
            } catch (e) {
                console.error("Erreur chargement settings:", e);
                if (configStatus) configStatus.innerHTML = `<p class="error">Erreur chargement paramètres: ${e.message}</p>`;
                BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;
            }
        }

        function saveSettings() {
            if (!configPanel || !configStatus) return;
            configStatus.innerHTML = '<p class="loading">Sauvegarde en cours...</p>';
            try {
                const newOrsKey = configOrsApiKeyInput.value.trim();
                const newGeminiKey = configGeminiApiKeyInput.value.trim();
                const newWeatherKey = configWeatherApiKeyInput.value.trim(); // ### NOUVEAU
                const newCenterLat = parseFloat(configMapCenterLatInput.value);
                const newCenterLon = parseFloat(configMapCenterLonInput.value);
                const newZoom = parseInt(configMapZoomInput.value, 10);
                const newBboxMarginPercent = parseInt(configBboxMarginInput.value, 10);
                const newPoiListLimit = parseInt(configPoiListLimitInput.value, 10);
                const newOverpassTimeout = parseInt(configOverpassTimeoutInput.value, 10);
                const newOverpassEndpoint = configOverpassEndpointInput.value.trim();
                const newRouteColor = configRouteColorInput.value;

                if (isNaN(newCenterLat) || isNaN(newCenterLon) || isNaN(newZoom) || isNaN(newBboxMarginPercent) || isNaN(newPoiListLimit) || isNaN(newOverpassTimeout) || !newOverpassEndpoint) {
                    throw new Error("Valeurs numériques invalides ou endpoint Overpass manquant.");
                }

                localStorage.setItem('orsApiKey', newOrsKey);
                localStorage.setItem('geminiApiKey', newGeminiKey);
                localStorage.setItem('weatherApiKey', newWeatherKey); // ### NOUVEAU

                localStorage.setItem('mapCenterLat', newCenterLat.toString());
                localStorage.setItem('mapCenterLon', newCenterLon.toString());
                localStorage.setItem('mapZoom', newZoom.toString());
                localStorage.setItem('bboxMarginPercent', newBboxMarginPercent.toString());
                localStorage.setItem('poiListLimit', newPoiListLimit.toString());
                localStorage.setItem('overpassTimeout', newOverpassTimeout.toString());
                localStorage.setItem('overpassEndpoint', newOverpassEndpoint);
                localStorage.setItem('routeColor', newRouteColor);

                ORS_API_KEY = newOrsKey;
                GEMINI_API_KEY = newGeminiKey;
                WEATHER_API_KEY = newWeatherKey;

                MAP_DEFAULT_CENTER = [newCenterLat, newCenterLon];
                MAP_DEFAULT_ZOOM = newZoom;
                BOUNDING_BOX_MARGIN_PERCENT = newBboxMarginPercent;
                POI_LIST_LIMIT = newPoiListLimit;
                OVERPASS_TIMEOUT = newOverpassTimeout;
                OVERPASS_API_ENDPOINT = newOverpassEndpoint;
                ROUTE_COLOR = newRouteColor;
                BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;

                if (GEMINI_API_KEY) {
                    GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                } else {
                    GEMINI_API_URL = '';
                }

                configStatus.innerHTML = '<p class="success">Paramètres enregistrés avec succès !</p>';

                if (map) map.setView(MAP_DEFAULT_CENTER, MAP_DEFAULT_ZOOM);
            } catch (e) {
                console.error("Erreur sauvegarde settings:", e);
                configStatus.innerHTML = `<p class="error">Erreur sauvegarde: ${e.message}</p>`;
            }
        }

        function toggleConfigPanel() {
            if (configPanel) configPanel.classList.toggle('visible');
        }

        // ########################################################################
        // ### GÉOLOCALISATION UTILISATEUR (NOUVEAU)
        // ########################################################################
        async function handleLocateMe() {
            if (!navigator.geolocation) {
                alert("Votre navigateur ne supporte pas la géolocalisation.");
                return;
            }
            locateMeBtn.disabled = true;
            locateMeBtn.classList.add('loading');
            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, timeout: 10000 });
                });
                const { latitude, longitude } = position.coords;
                if (startInput.value.trim() === '') {
                    startInput.value = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                } else {
                    endInput.value = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                }
                if (map) map.setView([latitude, longitude], 13);
            } catch (error) {
                console.error("Erreur géolocalisation:", error);
                alert("Impossible de vous localiser : " + error.message);
            } finally {
                locateMeBtn.disabled = false;
                locateMeBtn.classList.remove('loading');
            }
        }

        // ########################################################################
        // ### FONCTION PRINCIPALE DE RECHERCHE DE POI
        // ########################################################################
        async function handlePlanning() {
            clearPreviousResults();
            planBtn.disabled = true;
            planBtn.classList.add('loading');

            try {
                const startAddress = startInput.value.trim();
                const endAddress = endInput.value.trim();
                const interests = interestsInput.value.trim();
                if (!startAddress || !endAddress || !interests) {
                    throw new Error("Veuillez renseigner Départ, Arrivée et Intérêts.");
                }

                summaryDiv.innerHTML = '<p class="info">Calcul de la zone de recherche...</p>';
                const boundingBox = await getBoundingBox(startAddress, endAddress);
                if (!boundingBox) return;

                // On peut appeler l'IA pour générer la requête Overpass
                summaryDiv.innerHTML += '<p class="info">Génération de la requête Overpass via IA...</p>';
                const overpassQuery = await generateOverpassQueryFromAI(interests, boundingBox);

                summaryDiv.innerHTML += '<p class="info">Recherche POI via Overpass...</p>';
                const foundPois = await fetchPoisFromOverpass(overpassQuery);
                fullPoiList = foundPois;
                if (!foundPois || foundPois.length === 0) {
                    poiListDiv.innerHTML = '<p class="error">Aucun POI trouvé pour ces critères.</p>';
                    return;
                }

                summaryDiv.innerHTML += `<p class="success">${foundPois.length} POI trouvés dans la zone.</p>`;
                // Filtrer initialement (tous cochés)
                applyPoiFilters();
            } catch (error) {
                summaryDiv.innerHTML = `<p class="error">${error.message}</p>`;
            } finally {
                planBtn.disabled = false;
                planBtn.classList.remove('loading');
            }
        }

        // ########################################################################
        // ### APPLICATION DES FILTRES
        // ########################################################################
        function applyPoiFilters() {
            if (!fullPoiList || fullPoiList.length === 0) return;
            const checkedFilters = Array.from(poiFilterCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
            if (!checkedFilters || checkedFilters.length === 0) {
                displayPoisAndEnableSelection([]); // rien
                return;
            }
            const filterRegexes = checkedFilters.map(f => f.split(',').map(s => s.trim()));
            // Ex: [["viewpoint","panorama","paysage","scenic"],["park","parc","g..."], ...]
            // On considère qu'un POI match si l'un des mots-clés apparaît dans un de ses tags (clef ou valeur)
            const matchedPois = fullPoiList.filter(poi => {
                const tagString = Object.entries(poi.tags).map(([k, v]) => (k + '=' + v).toLowerCase()).join(' ');
                return filterRegexes.some(group => group.some(keyword => tagString.includes(keyword.toLowerCase())));
            });
            displayPoisAndEnableSelection(matchedPois);
        }

        function displayPoisAndEnableSelection(poisToDisplay) {
            poiListDiv.innerHTML = '';
            poiMarkerClusterGroup.clearLayers();
            poiMarkers = [];
            displayedPoiCount = 0;
            currentFilteredPoiList = poisToDisplay;

            if (!currentFilteredPoiList || currentFilteredPoiList.length === 0) {
                if (fullPoiList.length > 0) poiListDiv.innerHTML = '<p class="info">Aucun POI ne correspond aux filtres actifs.</p>';
                else poiListDiv.innerHTML = '<p class="info">Aucun POI trouvé.</p>';
                loadMoreBtn.style.display = 'none';
                updatePoiCount(0, 0);
                calculateSelectedRouteBtn.style.display = 'none';
                return;
            }
            // Afficher un premier lot
            displayMorePois();
            togglePoiLayerVisibility();
            calculateSelectedRouteBtn.style.display = 'block';
        }

        function displayMorePois() {
            const sourceList = currentFilteredPoiList;
            const isInitialDisplay = (displayedPoiCount === 0);
            const startIndex = displayedPoiCount;
            const endIndex = Math.min(startIndex + POI_LIST_LIMIT, sourceList.length);

            if (startIndex >= sourceList.length && !isInitialDisplay) {
                loadMoreBtn.style.display = 'none';
                return;
            }

            const listFragment = document.createDocumentFragment();
            const markersToAdd = [];

            if (isInitialDisplay) {
                poiMarkers = [];
                sourceList.forEach(poi => {
                    try {
                        if (!poi.coordinates?.[0] && !poi.coordinates?.[1]) return;
                        const isSelected = selectedPois.some(sp => sp.id === poi.id);
                        const marker = L.marker([poi.coordinates[1], poi.coordinates[0]], {
                            icon: isSelected ? selectedIcon : defaultIcon
                        });
                        
                        // ### NOUVEAU: Gestion horaires d’ouverture
                        // Si un tag opening_hours existe, on tente un affichage basique "Ouvert/Fermé"
                        let ohInfo = '';
                        if (poi.tags?.opening_hours) {
                            // Simplifié: On affiche juste la valeur. (Pour un vrai check, utiliser une lib opening_hours)
                            ohInfo = `<br><small>Horaires: ${poi.tags.opening_hours}</small>`;
                        }

                        let popupContent = `<b>${poi.name}</b><br><small>Type: ${poi.type}</small>${ohInfo}<small>ID: ${poi.id}</small>`;
                        marker.bindPopup(popupContent);
                        marker.poiData = poi;
                        marker.on('click', (e) => { togglePoiSelection(null, e.target); });
                        markersToAdd.push(marker);
                    } catch (e) { console.error("Erreur création marqueur:", e); }
                });
                poiMarkerClusterGroup.addLayers(markersToAdd);
                poiMarkers = markersToAdd;
                if (poiMarkers.length > 0 && map) {
                    try {
                        map.fitBounds(poiMarkerClusterGroup.getBounds().pad(0.1));
                    } catch (e) { console.warn("Impossible d'ajuster limites aux POI."); }
                }
            }

            for (let i = startIndex; i < endIndex; i++) {
                const poi = sourceList[i];
                const poiDiv = document.createElement('div');
                poiDiv.classList.add('poi-item');
                if (selectedPois.some(sp => sp.id === poi.id)) poiDiv.classList.add('selected');
                poiDiv.textContent = poi.name || `[${poi.type} #${poi.id}]`;
                poiDiv.title = `ID: ${poi.id} | Type: ${poi.type}\nTags: ${JSON.stringify(poi.tags, null, 1).substring(0, 200)}...`;
                poiDiv.dataset.poiId = poi.id;
                poiDiv.addEventListener('click', togglePoiSelection);
                listFragment.appendChild(poiDiv);
            }

            if (isInitialDisplay && poiListDiv.querySelector('.loading, .info')) {
                poiListDiv.innerHTML = '';
            }
            poiListDiv.appendChild(listFragment);
            displayedPoiCount = endIndex;
            updatePoiCount(displayedPoiCount, sourceList.length);
            loadMoreBtn.style.display = (displayedPoiCount < sourceList.length) ? 'inline-block' : 'none';
        }

        function updatePoiCount(displayedInList, totalFiltered) {
            if (poiCountSpan) {
                poiCountSpan.textContent = `(${displayedInList} / ${totalFiltered} filtrés / ${fullPoiList.length} total)`;
            }
        }

        function togglePoiLayerVisibility() {
            if (!map || !poiMarkerClusterGroup) return;
            if (togglePoiLayerCheckbox.checked) {
                if (!map.hasLayer(poiMarkerClusterGroup)) {
                    map.addLayer(poiMarkerClusterGroup);
                }
            } else {
                if (map.hasLayer(poiMarkerClusterGroup)) {
                    map.removeLayer(poiMarkerClusterGroup);
                }
            }
        }

        // ########################################################################
        // ### ITINÉRAIRE FINAL AVEC POI SÉLECTIONNÉS
        // ########################################################################
        async function handleRouteCalculationFinal() {
            if (!selectedPois || selectedPois.length === 0) {
                summaryDiv.innerHTML = '<p class="warning">Veuillez sélectionner au moins un POI.</p>';
                return;
            }
            calculateSelectedRouteBtn.disabled = true;
            calculateSelectedRouteBtn.classList.add('loading');
            clearRouteLayer();

            try {
                summaryDiv.innerHTML = '<p class="info">Calcul de l’itinéraire...</p>';
                instructionsDiv.innerHTML = '';

                const startAddress = startInput.value.trim();
                const endAddress = endInput.value.trim();
                const profile = profileSelect.value;
                const routePreference = routePrefSelect.value;

                const routeData = await getRouteFromOrs(startAddress, endAddress, selectedPois, profile, routePreference);
                if (!routeData?.features?.[0]) {
                    summaryDiv.innerHTML = '<p class="error">Données d’itinéraire invalides.</p>';
                    return;
                }

                drawRoute(routeData);
                displayRouteInstructions(routeData);

                // ### NOUVEAU: Météo rapide sur le point de départ ou d’arrivée (en option)
                if (WEATHER_API_KEY) {
                    try {
                        const [startLon, startLat] = await getOrsCoordinates(startAddress);
                        await fetchAndShowWeather(startLat, startLon, 'Départ');
                        const [endLon, endLat] = await getOrsCoordinates(endAddress);
                        await fetchAndShowWeather(endLat, endLon, 'Arrivée');
                    } catch (e) {
                        console.warn("Impossible de récupérer la météo:", e);
                    }
                }

                // ### NOUVEAU: Génération d’un résumé IA plus évolué, tenant compte du multi-jours
                const summaryText = await getAiRouteSummary(interestsInput.value, routeData, tripDaysCount);
                summaryDiv.innerHTML = `<div class="info">${summaryText}</div>`;

                // On active l’export GPX
                exportGpxBtn.style.display = 'block';
            } catch (error) {
                summaryDiv.innerHTML = `<p class="error">${error.message}</p>`;
            } finally {
                calculateSelectedRouteBtn.disabled = false;
                calculateSelectedRouteBtn.classList.remove('loading');
            }
        }

        function togglePoiSelection(e, markerRef) {
            let poiId, itemEl;
            if (markerRef) {
                // Clic sur la carte
                poiId = markerRef.poiData?.id;
                itemEl = poiListDiv.querySelector(`.poi-item[data-poi-id="${poiId}"]`);
            } else {
                // Clic dans la liste
                const divEl = e.currentTarget;
                poiId = divEl.dataset.poiId;
                itemEl = divEl;
            }
            if (!poiId) return;

            const poiIndex = selectedPois.findIndex(p => p.id == poiId);
            let newlySelected = false;
            if (poiIndex >= 0) {
                // Dé-sélection
                selectedPois.splice(poiIndex, 1);
                itemEl?.classList.remove('selected');
                // Changer l'icône sur la carte
                const marker = poiMarkers.find(m => m.poiData.id == poiId);
                if (marker) marker.setIcon(defaultIcon);
            } else {
                // Sélection
                const foundPoi = fullPoiList.find(p => p.id == poiId);
                if (foundPoi) {
                    selectedPois.push(foundPoi);
                    itemEl?.classList.add('selected');
                    newlySelected = true;
                    // Changer l'icône sur la carte
                    const marker = poiMarkers.find(m => m.poiData.id == poiId);
                    if (marker) marker.setIcon(selectedIcon);
                }
            }
        }

        // ########################################################################
        // ### APPELS API (ORS, GEMINI, OVERPASS) - inchangés sauf ajust. mineurs
        // ########################################################################
        async function getOrsCoordinates(address) {
            if (!address) return null;
            if (!ORS_API_KEY) throw new Error("Clé API OpenRouteService manquante.");

            // Permettre la saisie "lat, lon" directement
            const latLonMatch = address.match(/^(-?\d+(\.\d+)?)[,\s]+(-?\d+(\.\d+)?)$/);
            if (latLonMatch) {
                return [parseFloat(latLonMatch[3]), parseFloat(latLonMatch[1])];
            }

            const url = `https://api.openrouteservice.org/geocode/search?api_key=${ORS_API_KEY}&text=${encodeURIComponent(address)}&size=1`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Erreur Géocodage ORS (${response.status}) pour "${address}"`);
                }
                const data = await response.json();
                if (!data.features || data.features.length === 0) {
                    // Essai avec autocomplete
                    const autoUrl = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(address)}&size=1`;
                    const autoResp = await fetch(autoUrl);
                    if (!autoResp.ok) throw new Error(`Adresse non trouvée par ORS (search & autocomplete): "${address}"`);
                    const autoData = await autoResp.json();
                    if (!autoData.features || autoData.features.length === 0) {
                        throw new Error(`Adresse non trouvée: "${address}"`);
                    }
                    return autoData.features[0].geometry.coordinates; // [lon, lat]
                }
                return data.features[0].geometry.coordinates; // [lon, lat]
            } catch (error) {
                throw error;
            }
        }

        async function getBoundingBox(startAddress, endAddress) {
            try {
                const startCoords = await getOrsCoordinates(startAddress);
                const endCoords = await getOrsCoordinates(endAddress);
                if (!startCoords) throw new Error(`Adresse de départ "${startAddress}" introuvable.`);
                if (!endCoords) throw new Error(`Adresse d'arrivée "${endAddress}" introuvable.`);

                const [lon1, lat1] = startCoords;
                const [lon2, lat2] = endCoords;

                const margin = BOUNDING_BOX_MARGIN;
                const minLat = Math.min(lat1, lat2);
                const maxLat = Math.max(lat1, lat2);
                const minLon = Math.min(lon1, lon2);
                const maxLon = Math.max(lon1, lon2);

                // Ajustements
                const south = Math.max(-90, minLat - margin);
                const north = Math.min(90, maxLat + margin);
                const west = Math.max(-180, minLon - margin);
                const east = Math.min(180, maxLon + margin);

                return { south, west, north, east };
            } catch (error) {
                summaryDiv.innerHTML = `<p class="error">Erreur BBox: ${error.message}</p>`;
                return null;
            }
        }

        /** Génère requête Overpass via IA (INTERDICTION REGEX '~') */
        async function generateOverpassQueryFromAI(interests, boundingBox) {
             if (!boundingBox || typeof boundingBox.south !== 'number') {
                 throw new Error("BBox invalide pour l'IA.");
             }
             // Bbox string SANS les parenthèses autour
             const bboxString = `${boundingBox.south.toFixed(6)},${boundingBox.west.toFixed(6)},${boundingBox.north.toFixed(6)},${boundingBox.east.toFixed(6)}`;

             // --- PROMPT DÉTAILLÉ POUR GEMINI (INTERDICTION REGEX) ---
             const prompt = `
                  Tu es un expert mondial en données OpenStreetMap (OSM) et dans le langage de requête Overpass QL.
                  L'utilisateur souhaite planifier un itinéraire et a décrit ses intérêts.
                  Ta tâche est de générer une requête Overpass QL complète et optimisée pour trouver des points d'intérêt (POI) pertinents (nodes, ways, relations) dans une zone géographique donnée.

                  Intérêts de l'utilisateur: "${interests}"

                  Zone géographique (bounding box au format south, west, north, east): ${bboxString}

                  Instructions pour la requête Overpass QL:
                  1.  **Format de Sortie Obligatoire:** Commence par \`[out:json][timeout:${OVERPASS_TIMEOUT}];\` et termine par \`out center;\`.
                  2.  **Application de la Zone:** Applique le bounding box \`${bboxString}\` DIRECTEMENT après le tag/filtre, SANS parenthèses supplémentaires autour des coordonnées. Syntaxe CORRECTE : \`type[tag](south,west,north,east);\`. Exemple: \`node["amenity"="restaurant"](${bboxString});\`.
                  3.  **Pertinence des Tags:** Traduis les 'intérêts' en tags OSM pertinents. Concentre-toi sur :
                      * **Vues/Paysages:** \`tourism=viewpoint\`, \`natural=peak\`, \`man_made=lighthouse\`, zones \`natural=wood\`, \`natural=water\`, \`natural=heath\`, \`natural=grassland\`, \`highway=passing_place\` (si vue).
                      * **Parcs/Nature:** \`leisure=park\`, \`leisure=nature_reserve\`, \`boundary=national_park\`, \`boundary=protected_area\`, \`leisure=garden\`.
                      * **Terroir/Marchés:** \`amenity=marketplace\`, \`shop=farm\`, \`shop=deli\`, \`shop=cheese\`, \`shop=wine\`, \`craft=brewery\`, \`craft=pottery\`, \`amenity=restaurant\` (avec cuisine locale si possible, mais difficile à tagger).
                      * **Oiseaux/Faune:** \`leisure=bird_hide\`, \`tourism=attraction[attraction=animal]\`, zones \`natural=wetland\`, \`natural=scree\`.
                      * **Histoire/Culture:** \`historic=*\` (castle, ruins, monument, archaeological_site, memorial, church), \`tourism=museum\`, \`tourism=attraction\`, \`amenity=theatre\`, \`amenity=arts_centre\`.
                      * **Eau/Plages:** \`natural=water\`, \`natural=coastline\`, \`natural=beach\`, \`natural=spring\`, \`waterway=waterfall\`, \`natural=bay\`.
                      * **Villages:** Chercher \`place=village\` ou \`place=hamlet\` et inclure les éléments historiques/touristiques à l'intérieur ou très proches.
                  4.  **Structure de la Requête:** Utilise une union \`( ... );\` pour regrouper les différentes recherches. Exemple: \`( node["tourism"="viewpoint"](${bboxString}); way["leisure"="park"](${bboxString}); );\`. Point-virgule sépare chaque clause DANS l'union.
                  5.  **Performance:** Cible les tags spécifiques. Évite les requêtes trop génériques comme \`["natural"]\` seul. Utilise \`node\`, \`way\`, \`relation\` de manière appropriée. Pour les zones (way/relation), demande \`out center;\` pour obtenir un point central. Ne cherche pas \`relation\` sauf pour \`boundary=*\`, \`type=route\` (sentiers) ou zones complexes si nécessaire.
                  6.  **Nommage:** Priorise les éléments ayant un tag \`name\` mais inclus aussi ceux sans nom si le tag principal est très descriptif (ex: viewpoint).
                  7.  **Syntaxe Strict des Filtres:** Utilise **UNIQUEMENT** des correspondances exactes avec '=' (ex: \`["amenity"="restaurant"]\`), des vérifications d'existence de clé (ex: \`["historic"]\`) ou des non-égalités \`!=\` (ex: \`["historic"!="no"]\`). **N'utilise JAMAIS l'opérateur regex '~' ou de regex complexe**.
                  8.  **Sortie Brute:** Ne génère QUE la requête Overpass QL valide. Pas de commentaires dans la requête, pas d'explications avant/après, pas de formatage Markdown (\`\`\`). Commence directement par \`[out:json]...\`.

                  Requête Overpass QL générée:
             `;
             // --- FIN DU PROMPT ---

             try {
                 console.log("Prompt Gemini (Query Gen) avec BBox:", bboxString);
                 // console.log("Prompt envoyé:", prompt); // Décommenter pour vérifier le prompt complet
                 const response = await fetch(GEMINI_API_URL, {
                     method: 'POST', headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: 0.3, topP: 0.95 } }) // Température basse pour requête précise
                 });
                 if (!response.ok) {
                     let errorMsg = `Erreur API Gemini (${response.status}) Query Gen.`; try { errorMsg += ` Détail: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){} throw new Error(errorMsg);
                 }
                 const data = await response.json();
                 // console.log("Réponse brute Gemini:", JSON.stringify(data)); // Pour débugger la réponse
                 if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                     // Gestion spécifique si Gemini refuse de répondre (sécurité, etc.)
                     const safetyFeedback = data.promptFeedback?.safetyRatings;
                     if (safetyFeedback && safetyFeedback.some(r => r.blocked)) {
                         console.error("Réponse Gemini bloquée pour des raisons de sécurité:", safetyFeedback);
                         throw new Error("L'IA a refusé de générer la requête (possible contenu inapproprié dans les intérêts?).");
                     }
                     console.error("Réponse Gemini (Query Gen) inattendue:", JSON.stringify(data)); throw new Error("Structure réponse IA inattendue (Query Gen).");
                 }
                 const generatedQuery = data.candidates[0].content.parts[0].text;

                 // Nettoyage et Validation renforcée
                 const cleanedQuery = generatedQuery.replace(/```(ql|overpass)?\s*|\s*```/g, '').trim();
                 if (!cleanedQuery.startsWith('[out:json]') || !cleanedQuery.includes('out center;')) {
                     console.error("Requête générée invalide ou vide:", cleanedQuery);
                     if (cleanedQuery.length < 50 && cleanedQuery.toLowerCase().includes("prompt")) {
                         throw new Error("L'IA a répondu au lieu de générer la requête (vérifiez le prompt envoyé).");
                     } else {
                         throw new Error("L'IA n'a pas généré une requête Overpass QL valide (format incorrect ou vide).");
                     }
                 }
                 // Vérification supplémentaire: absence de l'opérateur ~ ou regex complexe
                 if (cleanedQuery.match(/~|\[".*?"~".*?"\]/)) {
                      console.error("Erreur critique: L'IA a utilisé un opérateur regex interdit ('~' ou similar) !", cleanedQuery);
                      throw new Error("Erreur de syntaxe générée par l'IA (opérateur regex interdit utilisé). Modifiez vos intérêts ou réessayez.");
                 }
                 // Vérifier que la bbox est bien présente dans la requête
                 if (!cleanedQuery.includes(bboxString.substring(0, 10))) { // Vérifie juste le début de la bbox
                    console.error("Erreur critique: La BBox semble manquante dans la requête générée !", cleanedQuery);
                    throw new Error("Erreur de génération IA : la zone géographique (bbox) est manquante dans la requête Overpass.");
                 }


                 console.log("Requête Overpass générée par IA (nettoyée):", cleanedQuery);
                 return cleanedQuery;
             } catch (error) {
                 console.error("Erreur appel IA (Query Gen):", error);
                 throw new Error(`Génération requête IA échouée: ${error.message}`);
             }
        }


        async function fetchPoisFromOverpass(query) {
            if (!OVERPASS_API_ENDPOINT) throw new Error("Endpoint Overpass non configuré.");
            if (!query) return [];

            poiListDiv.innerHTML = `<p class="loading">Recherche POI via Overpass (${OVERPASS_TIMEOUT}s max)...</p>`;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), (OVERPASS_TIMEOUT + 5) * 1000);

                const response = await fetch(OVERPASS_API_ENDPOINT, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(query)}`,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                        'Accept': 'application/json'
                    },
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Erreur Overpass (${response.status}): ${errorText}`);
                }
                const data = await response.json();
                const pois = data.elements.map(el => {
                    let name = el.tags?.name;
                    if (!name) {
                        const altName = el.tags?.alt_name || el.tags?.official_name;
                        if (altName) name = altName;
                    }
                    if (!name) {
                        name = `[${el.type} #${el.id}]`;
                    }
                    const lon = el.lon ?? el.center?.lon;
                    const lat = el.lat ?? el.center?.lat;
                    if (lon == null || lat == null) return null;
                    return {
                        id: el.id,
                        type: el.type,
                        name,
                        coordinates: [lon, lat],
                        tags: el.tags || {}
                    };
                }).filter(Boolean);

                const uniquePois = Array.from(new Map(pois.map(p => [p.id, p])).values());
                return uniquePois;
            } catch (error) {
                throw error;
            }
        }

        async function getRouteFromOrs(startAddress, endAddress, waypoints, profile, routePreference) {
            if (!ORS_API_KEY) {
                throw new Error("Clé API ORS manquante.");
            }
            summaryDiv.innerHTML += '<p class="loading info">... géocodage départ/arrivée ...</p>';
            const startCoords = await getOrsCoordinates(startAddress);
            const endCoords = await getOrsCoordinates(endAddress);
            if (!startCoords) throw new Error(`Départ introuvable pour routage.`);
            if (!endCoords) throw new Error(`Arrivée introuvable pour routage.`);

            const allCoordinates = [startCoords, ...waypoints.map(p => p.coordinates), endCoords];
            let orsOptions = {};
            let orsPreference = 'recommended';

            if (profile === 'driving-car' || profile === 'driving-hgv') {
                const avoidFeatures = [];
                if (routePreference === 'AVOID_HIGHWAYS') avoidFeatures.push('highways');
                if (routePreference === 'AVOID_TOLLS') avoidFeatures.push('tollways');
                if (avoidFeatures.length > 0) orsOptions.avoid_features = avoidFeatures;
                if (routePreference === 'SHORTEST') orsPreference = 'shortest';
                else if (routePreference === 'FASTEST') orsPreference = 'fastest';
            } else if (profile === 'cycling-regular') {
                orsPreference = 'recommended';
            } else if (profile === 'foot-walking') {
                orsPreference = 'shortest';
            }

            const url = `https://api.openrouteservice.org/v2/directions/${profile}/geojson`;
            const body = {
                coordinates: allCoordinates,
                language: 'fr',
                instructions: true,
                instructions_format: "text",
                preference: orsPreference,
                units: "km"
            };
            if (Object.keys(orsOptions).length > 0) {
                body.options = orsOptions;
            }

            summaryDiv.innerHTML += '<p class="loading info">...appel API routage ORS...</p>';

            const response = await fetch(url, {
                method: 'POST',
                body: JSON.stringify(body),
                headers: {
                    'Authorization': ORS_API_KEY,
                    'Content-Type': 'application/json; charset=utf-8',
                    'Accept': 'application/json, application/geo+json, */*'
                }
            });
            if (!response.ok) {
                let errJson;
                try { errJson = await response.json(); } catch { errJson = {}; }
                throw new Error(`Erreur Routage ORS (${response.status}): ${errJson?.error?.message || response.statusText}`);
            }
            return await response.json();
        }

        async function getAiRouteSummary(interests, routeData, nbJours) {
            if (!GEMINI_API_KEY || !GEMINI_API_URL) {
                return "<p class='warning'>Résumé IA non disponible (clés Gemini manquantes).</p>";
            }
            if (!routeData?.features?.[0]?.properties) {
                return "<p class='error'>Données itinéraire manquantes pour résumé IA.</p>";
            }
            const summary = routeData.features[0].properties.summary;
            const distanceKm = (summary.distance).toFixed(1);
            const durationMin = Math.round(summary.duration / 60);

            let poiNames = selectedPois.map(p => p.name).join(', ');
            if (!poiNames) poiNames = "quelques points d'intérêt";
            
            // Petit prompt IA
            const prompt = `
[SYSTEM]
Tu es un assistant de voyage enthousiaste. Rédige un bref paragraphe (3-5 phrases) EN FRANÇAIS qui résume l'itinéraire. 
Le voyage s'étale sur ${nbJours} jour(s). 
Intérêts: "${interests}". 
POIs: ${poiNames}. 
Distance totale: ${distanceKm} km. Durée estimée: ${durationMin} min.
Propose une répartition sur ${nbJours} jour(s) si pertinent, en mentionnant éventuellement les points forts. 
Ton: Positif et inspirant.
[/SYSTEM]
Texte :`;

            try {
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.7, topP: 0.9 }
                    })
                });
                if (!response.ok) {
                    return `<p class="error">Erreur API Gemini (${response.status}) pour résumé.</p>`;
                }
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || '';
                if (!text) {
                    return "<p class='error'>IA n'a pas pu générer de résumé.</p>";
                }
                return text.replace(/[\r\n]+/g, ' ');
            } catch (error) {
                return `<p class="error">Impossible de générer le résumé IA: ${error.message}</p>`;
            }
        }

        // ########################################################################
        // ### AFFICHAGE ITINÉRAIRE SUR CARTE & INSTRUCTIONS
        // ########################################################################
        function drawRoute(routeData) {
            if (routeLayer) {
                map.removeLayer(routeLayer);
            }
            routeLayer = L.geoJSON(routeData, {
                style: {
                    color: ROUTE_COLOR,
                    weight: 5,
                    opacity: 0.8
                }
            }).addTo(map);

            if (map && routeLayer) {
                try {
                    map.fitBounds(routeLayer.getBounds().pad(0.1));
                } catch (e) { console.warn("Impossible de fitBounds route."); }
            }
        }

        function displayRouteInstructions(routeData) {
            if (!routeData?.features?.[0]?.properties?.segments) {
                instructionsDiv.innerHTML = '<p class="error">Aucune instruction.</p>';
                return;
            }
            const segments = routeData.features[0].properties.segments;
            const allSteps = segments.flatMap(seg => seg.steps || []);
            if (allSteps.length === 0) {
                instructionsDiv.innerHTML = '<p class="info">Aucune instruction détaillée trouvée.</p>';
                return;
            }
            let html = '<h4>Instructions détaillées</h4><ol>';
            allSteps.forEach(step => {
                html += `<li><strong>${step.instruction}</strong> (${step.distance.toFixed(1)} m, ~${Math.round(step.duration / 60)} min)</li>`;
            });
            html += '</ol>';
            instructionsDiv.innerHTML = html;
        }

        // ########################################################################
        // ### MÉTÉO (NOUVEAU)
        // ########################################################################
        async function fetchAndShowWeather(lat, lon, label) {
            if (!WEATHER_API_KEY) return;
            const url = `${WEATHER_API_URL}?lat=${lat}&lon=${lon}&appid=${WEATHER_API_KEY}&units=metric&lang=fr`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Erreur météo (${response.status})`);
                const data = await response.json();
                const weatherDesc = data.weather?.[0]?.description || 'météo inconnue';
                const temp = data.main?.temp?.toFixed(1) || '?';
                summaryDiv.innerHTML += `<p class="info">${label}: ${temp}°C, ${weatherDesc}</p>`;
            } catch (e) {
                console.warn("fetchAndShowWeather:", e);
            }
        }

        // ########################################################################
        // ### EXPORT GPX (NOUVEAU)
        // ########################################################################
        function exportGpx() {
            if (!routeLayer || !routeLayer.toGeoJSON) {
                alert("Aucun itinéraire à exporter.");
                return;
            }
            const geoJson = routeLayer.toGeoJSON();
            // On construit un GPX basique
            // NB: Pour un export GPX plus complet, utiliser une librairie (togeojson, omnivore, etc.).
            let gpx = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<gpx version="1.1" creator="MonAppliIA" xmlns="http://www.topografix.com/GPX/1/1">
<metadata><name>Itinéraire IA</name></metadata>
<trk><name>Itinéraire sélectionné</name><trkseg>
`;

            // Parcours des points de la géométrie
            const coords = geoJson.features[0].geometry.coordinates;
            coords.forEach(([lon, lat]) => {
                gpx += `<trkpt lat="${lat}" lon="${lon}"></trkpt>\n`;
            });

            gpx += `</trkseg></trk>\n`;

            // Optionnel: On peut ajouter les POI sélectionnés en waypoints
            selectedPois.forEach(poi => {
                gpx += `<wpt lat="${poi.coordinates[1]}" lon="${poi.coordinates[0]}">
  <name>${poi.name}</name>
</wpt>\n`;
            });

            gpx += `</gpx>`;

            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'itineraire_IA.gpx';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        // ########################################################################
        // ### UTILS
        // ########################################################################
        function clearPreviousResults() {
            summaryDiv.innerHTML = '';
            instructionsDiv.innerHTML = '';
            poiListDiv.innerHTML = 'Prêt à chercher des POI.';
            fullPoiList = [];
            currentFilteredPoiList = [];
            selectedPois = [];
            displayedPoiCount = 0;
            loadMoreBtn.style.display = 'none';
            calculateSelectedRouteBtn.style.display = 'none';
            clearRouteLayer();
        }

        function clearRouteLayer() {
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            exportGpxBtn.style.display = 'none';
        }
    </script>
</body>
</html>
