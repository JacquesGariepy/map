<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Planificateur d'Itinéraire IA - Configuration Avancée</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin=""/>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin=""></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="container">
        <div id="sidebar">
             
           

            <h3>Planificateur d'Itinéraire IA</h3>

            <button id="locateMeBtn">
                <i class="fa-solid fa-location-crosshairs"></i> <span>Me Localiser</span>
                 <span class="spinner"></span> </button>

             <label for="start">Départ :</label>
            <input type="text" id="start" placeholder="Adresse, lieu ou 'lat, lon'">

            <label for="end">Arrivée :</label>
            <input type="text" id="end" placeholder="Adresse, lieu ou 'lat, lon'">

            <label for="interests">Décrivez vos intérêts pour ce voyage :</label>
            <textarea id="interests" placeholder="Ex: Paysages magnifiques, villages pittoresques, éviter les autoroutes, produits locaux, etc."></textarea>

            <label for="profile">Profil de déplacement :</label>
            <select id="profile">
                <option value="driving-car" selected>Voiture</option>
                <option value="driving-hgv">Camion / Poids Lourd</option>
                <option value="cycling-regular">Vélo</option>
                <option value="foot-walking">Marche</option>
            </select>

            <label for="routePref">Préférence d'itinéraire (si applicable) :</label>
            <select id="routePref">
                <option value="FASTEST" selected>Le plus rapide</option>
                <option value="SHORTEST">Le plus court</option>
                <option value="AVOID_HIGHWAYS">Éviter les autoroutes</option>
                <option value="AVOID_TOLLS">Éviter les péages</option>
            </select>

            <label for="tripDays">Plan sur plusieurs jours :</label>
            <input type="number" id="tripDays" min="1" max="30" step="1" value="1" />

            <button id="planRouteBtn">
                <i class="fa-solid fa-search-location"></i> <span class="button-text">1. Trouver POI Pertinents</span>
                <span class="spinner"></span>
            </button>

            <div id="poiPanel">
                <h4>Points d'intérêt <span id="poiCount"></span></h4>
                <div id="poiFilters">
                    <label title="Points de vue, panoramas, paysages">
                        <input type="checkbox" class="poi-filter" value="viewpoint,panorama,paysage,scenic,peak,lighthouse,passing_place" checked>
                        Vues & Paysages
                    </label>
                    <label title="Parcs, jardins, réserves naturelles">
                        <input type="checkbox" class="poi-filter" value="park,parc,garden,jardin,reserve,réserve,natural=wood,natural=heath,natural=grassland,boundary=national_park,boundary=protected_area" checked>
                        Parcs/Nature
                    </label>
                    <label title="Magasins fermiers, marchés, produits locaux, artisanat">
                        <input type="checkbox" class="poi-filter" value="farm,ferme,market,marché,local,terroir,produit,shop=farm,amenity=marketplace,shop=deli,shop=cheese,shop=wine,craft=brewery,craft=pottery" checked>
                        Terroir/Marchés
                    </label>
                    <label title="Observation oiseaux, refuges animaliers, zones naturelles spécifiques">
                        <input type="checkbox" class="poi-filter" value="bird,oiseau,hide,observatoire,wildlife,leisure=bird_hide,attraction=animal,natural=wetland,natural=scree" checked>
                        Oiseaux/Faune
                    </label>
                    <label title="Sites historiques, châteaux, ruines, musées, culture">
                        <input type="checkbox" class="poi-filter" value="historic,castle,château,ruin,ruine,monument,museum,musée,archaeological_site,memorial,church,tourism=attraction,amenity=theatre,amenity=arts_centre" checked>
                        Histoire/Culture
                    </label>
                    <label title="Lacs, rivières, plages, cascades, côtes">
                        <input type="checkbox" class="poi-filter" value="water,beach,river,lake,waterfall,eau,plage,rivière,lac,cascade,natural=water,natural=coastline,natural=beach,natural=spring,waterway=waterfall,natural=bay" checked>
                        Eau/Plages
                    </label>
                    <label title="Villages, lieux pittoresques">
                        <input type="checkbox" class="poi-filter" value="village,hamlet,pittoresque,place=village,place=hamlet" checked>
                        Villages
                    </label>
                </div>
                <div id="showPoiToggle">
                    <label>
                        <input type="checkbox" id="togglePoiLayer" checked>
                        Afficher POI sur la carte
                    </label>
                </div>
                <div id="poiList" class="loading" aria-live="polite">Prêt à chercher des POI.</div>
                <button id="loadMoreBtn" style="display: none;">
                    <i class="fa-solid fa-chevron-down"></i> Afficher plus
                </button>
            </div>

            <button id="calculateSelectedRouteBtn" style="display: none;">
                <i class="fa-solid fa-route"></i>
                <span class="button-text">2. Calculer Itinéraire via Sélection</span>
                <span class="spinner"></span>
            </button>

            <div id="resultsPanel">
                <h4>Itinéraire et Résumé</h4>
                <div id="routeSummary" class="loading" aria-live="polite">Prêt à calculer l'itinéraire.</div>

                <div id="weatherDisplay">
                    </div>

                <div id="routeInstructions"></div>

                <button id="exportGpxBtn" style="display: none; background-color:#444; color:#fff; margin-top: 15px;">
                    <i class="fa-solid fa-download"></i> Export GPX
                </button>
            </div>

           
            <button id="toggleConfigBtn" title="Ouvrir les Paramètres">
                <i class="fa-solid fa-gear"></i>
            </button>
            

            <div id="configPanel">
                <h4>
                    Paramètres de l'Application
                    <button id="closeConfigBtn"><i class="fa-solid fa-times"></i> Fermer</button>
                </h4>

                <p style="font-size: 0.8rem; color: var(--color-danger); margin-bottom: 15px; border: 1px solid var(--color-danger); padding: 8px; border-radius: var(--border-radius); background-color: var(--color-danger-light);">
                    <i class="fa-solid fa-triangle-exclamation"></i> <strong>ATTENTION:</strong> Les clés API sont stockées localement dans votre navigateur (localStorage). Ne partagez pas cet ordinateur et soyez conscient que cette méthode n'est <strong>PAS SÉCURISÉE</strong> pour un usage public ou en production.
                </p>

                <label for="configOrsApiKey">Clé API OpenRouteService :</label>
                <input type="password" id="configOrsApiKey" placeholder="Entrez votre clé ORS">

                <label for="configGeminiApiKey">Clé API Google Gemini :</label>
                <input type="password" id="configGeminiApiKey" placeholder="Entrez votre clé Gemini">

                <label for="configWeatherApiKey">Clé API OpenWeatherMap :</label>
                <input type="password" id="configWeatherApiKey" placeholder="Entrez votre clé OpenWeatherMap">

                <div class="input-group">
                    <div>
                        <label for="configMapCenterLat">Centre Carte Lat Défaut :</label>
                        <input type="number" id="configMapCenterLat" step="0.0001">
                    </div>
                    <div>
                        <label for="configMapCenterLon">Centre Carte Lon Défaut :</label>
                        <input type="number" id="configMapCenterLon" step="0.0001">
                    </div>
                </div>

                <label for="configMapZoom">Zoom Carte Défaut :</label>
                <input type="number" id="configMapZoom" min="1" max="19" step="1">

                <label for="configRouteColor">Couleur Itinéraire :</label>
                <input type="color" id="configRouteColor">

                <label for="configBboxMargin">Marge Zone Recherche (%):</label>
                <input type="number" id="configBboxMargin" min="0" max="100" step="1" title="Pourcentage (0-100) ajouté autour des points départ/arrivée pour chercher les POI. 15% = 0.15 degrés env.">

                <label for="configPoiListLimit">Limite POI par Page (Liste) :</label>
                <input type="number" id="configPoiListLimit" min="5" max="200" step="5">

                <label for="configOverpassTimeout">Timeout Overpass (secondes) :</label>
                <input type="number" id="configOverpassTimeout" min="10" max="180" step="5">

                <label for="configOverpassEndpoint">Endpoint API Overpass :</label>
                <input type="text" id="configOverpassEndpoint" placeholder="URL de l'instance Overpass">

                <button id="saveConfigBtn">
                    <i class="fa-solid fa-save"></i> Enregistrer les Paramètres
                </button>
                <div id="configStatus"></div>
            </div>
        </div>

        <div id="map"></div>

    </div>

    <script>
        // --- Configuration Globale (sera écrasée par localStorage si présent) ---
        let ORS_API_KEY = '';
        let GEMINI_API_KEY = '';
        let GEMINI_API_URL = '';
        let WEATHER_API_KEY = '';
        let WEATHER_API_URL = 'https://api.openweathermap.org/data/2.5/weather';
        let WEATHER_ICON_URL = 'https://openweathermap.org/img/wn/'; // Base URL for OWM icons

        let MAP_DEFAULT_CENTER = [48.8566, 2.3522]; // Paris, FR
        let MAP_DEFAULT_ZOOM = 6;
        let BOUNDING_BOX_MARGIN_PERCENT = 15;
        let POI_LIST_LIMIT = 30;
        let OVERPASS_TIMEOUT = 35;
        let OVERPASS_API_ENDPOINT = 'https://overpass-api.de/api/interpreter';
        let ROUTE_COLOR = '#3B82F6';

        // Variable calculée
        let BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;

        // --- Variables Globales (état de l'application) ---
        let map;
        let routeLayer = null;
        let fullPoiList = [];
        let displayedPoiCount = 0;
        let selectedPois = [];
        let poiMarkerClusterGroup = null;
        let currentFilteredPoiList = [];
        let poiMarkers = [];
        let tripDaysCount = 1;

        // --- Icônes Leaflet ---
        const defaultIcon = new L.Icon.Default();
        const selectedIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        // --- Initialisation Leaflet & MarkerCluster ---
        try {
            map = L.map('map'); // Pas besoin de options ici, on setView plus tard
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors'
            }).addTo(map);
            poiMarkerClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 60
            });
        } catch (e) {
            console.error("Erreur critique initialisation Leaflet:", e);
            alert("Erreur critique: Impossible d'initialiser la carte Leaflet.");
        }

        // --- Références DOM ---
        const sidebar = document.getElementById('sidebar'); // Ajout référence sidebar
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn'); // Ajout référence bouton toggle
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        const interestsInput = document.getElementById('interests');
        const profileSelect = document.getElementById('profile');
        const routePrefSelect = document.getElementById('routePref');
        const planBtn = document.getElementById('planRouteBtn');
        const calculateSelectedRouteBtn = document.getElementById('calculateSelectedRouteBtn');
        const poiPanel = document.getElementById('poiPanel');
        const poiListDiv = document.getElementById('poiList');
        const poiCountSpan = document.getElementById('poiCount');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        const poiFilterCheckboxes = document.querySelectorAll('.poi-filter');
        const togglePoiLayerCheckbox = document.getElementById('togglePoiLayer');
        const summaryDiv = document.getElementById('routeSummary');
        const instructionsDiv = document.getElementById('routeInstructions');
        const toggleConfigBtn = document.getElementById('toggleConfigBtn');
        const configPanel = document.getElementById('configPanel');
        const closeConfigBtn = document.getElementById('closeConfigBtn');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const configStatus = document.getElementById('configStatus');
        const configOrsApiKeyInput = document.getElementById('configOrsApiKey');
        const configGeminiApiKeyInput = document.getElementById('configGeminiApiKey');
        const configWeatherApiKeyInput = document.getElementById('configWeatherApiKey');
        const configMapCenterLatInput = document.getElementById('configMapCenterLat');
        const configMapCenterLonInput = document.getElementById('configMapCenterLon');
        const configMapZoomInput = document.getElementById('configMapZoom');
        const configRouteColorInput = document.getElementById('configRouteColor');
        const configBboxMarginInput = document.getElementById('configBboxMargin');
        const configPoiListLimitInput = document.getElementById('configPoiListLimit');
        const configOverpassTimeoutInput = document.getElementById('configOverpassTimeout');
        const configOverpassEndpointInput = document.getElementById('configOverpassEndpoint');
        const locateMeBtn = document.getElementById('locateMeBtn');
        const tripDaysInput = document.getElementById('tripDays');
        const exportGpxBtn = document.getElementById('exportGpxBtn');
        const weatherDisplayDiv = document.getElementById('weatherDisplay');

        // --- Écouteurs d'Événements ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();

            if (map) {
                map.setView(MAP_DEFAULT_CENTER, MAP_DEFAULT_ZOOM);
                if (togglePoiLayerCheckbox && togglePoiLayerCheckbox.checked) {
                    map.addLayer(poiMarkerClusterGroup);
                }
                 // Invalidate map size slightly after initial load, in case sidebar affects layout early
                setTimeout(() => { map.invalidateSize() }, 100);
            }

             // --- NOUVEAU : Gestion Toggle Sidebar ---
            if (toggleSidebarBtn && sidebar && map) {
                const mapInstance = map; // Alias pour clarté dans la portée
                toggleSidebarBtn.addEventListener('click', () => {
                    sidebar.classList.toggle('hidden');
                    const isHidden = sidebar.classList.contains('hidden');

                    // Ajuster l'icône et le title du bouton
                    const icon = toggleSidebarBtn.querySelector('i');
                    if (icon) {
                        icon.classList.toggle('fa-chevron-left', !isHidden);
                        icon.classList.toggle('fa-chevron-right', isHidden);
                    }
                    toggleSidebarBtn.title = isHidden ? "Afficher le panneau" : "Masquer le panneau";

                    // Redimensionner la map Leaflet après la transition CSS
                    setTimeout(() => {
                        mapInstance.invalidateSize();
                    }, 380); // Doit correspondre ou être > à la durée de transition CSS
                });
            } else {
                 console.warn("Éléments Sidebar Toggle ou Map non trouvés pour l'event listener.");
            }
             // --- FIN Toggle Sidebar ---

            if (locateMeBtn) locateMeBtn.addEventListener('click', handleLocateMe);
            if (planBtn) planBtn.addEventListener('click', handlePlanning);
            if (calculateSelectedRouteBtn) calculateSelectedRouteBtn.addEventListener('click', handleRouteCalculationFinal);
            if (loadMoreBtn) loadMoreBtn.addEventListener('click', () => displayMorePois());
            if (togglePoiLayerCheckbox) togglePoiLayerCheckbox.addEventListener('change', togglePoiLayerVisibility);
            poiFilterCheckboxes.forEach(checkbox => checkbox.addEventListener('change', applyPoiFilters));
            if (toggleConfigBtn) toggleConfigBtn.addEventListener('click', toggleConfigPanel);
            if (closeConfigBtn) closeConfigBtn.addEventListener('click', toggleConfigPanel);
            if (saveConfigBtn) saveConfigBtn.addEventListener('click', saveSettings);
            if (tripDaysInput) tripDaysInput.addEventListener('change', (e) => {
                tripDaysCount = parseInt(e.target.value, 10) || 1;
            });
            if (exportGpxBtn) exportGpxBtn.addEventListener('click', exportGpx);

            clearPreviousResults();
        });

        // ########################################################################
        // ### GESTION DES PARAMÈTRES (LocalStorage)
        // ########################################################################
        function loadSettings() {
            try {
                ORS_API_KEY = localStorage.getItem('orsApiKey') || '';
                GEMINI_API_KEY = localStorage.getItem('geminiApiKey') || '';
                WEATHER_API_KEY = localStorage.getItem('weatherApiKey') || '';

                const savedCenterLat = localStorage.getItem('mapCenterLat');
                const savedCenterLon = localStorage.getItem('mapCenterLon');
                MAP_DEFAULT_CENTER = (savedCenterLat && savedCenterLon) ? [parseFloat(savedCenterLat), parseFloat(savedCenterLon)] : MAP_DEFAULT_CENTER;

                MAP_DEFAULT_ZOOM = parseInt(localStorage.getItem('mapZoom') || MAP_DEFAULT_ZOOM, 10);
                BOUNDING_BOX_MARGIN_PERCENT = parseInt(localStorage.getItem('bboxMarginPercent') || BOUNDING_BOX_MARGIN_PERCENT, 10);
                POI_LIST_LIMIT = parseInt(localStorage.getItem('poiListLimit') || POI_LIST_LIMIT, 10);
                OVERPASS_TIMEOUT = parseInt(localStorage.getItem('overpassTimeout') || OVERPASS_TIMEOUT, 10);
                OVERPASS_API_ENDPOINT = localStorage.getItem('overpassEndpoint') || OVERPASS_API_ENDPOINT;
                ROUTE_COLOR = localStorage.getItem('routeColor') || ROUTE_COLOR;

                BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;

                if (GEMINI_API_KEY) {
                    GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                } else {
                    GEMINI_API_URL = '';
                }

                if (configOrsApiKeyInput) configOrsApiKeyInput.value = ORS_API_KEY;
                if (configGeminiApiKeyInput) configGeminiApiKeyInput.value = GEMINI_API_KEY;
                if (configWeatherApiKeyInput) configWeatherApiKeyInput.value = WEATHER_API_KEY;
                if (configMapCenterLatInput) configMapCenterLatInput.value = MAP_DEFAULT_CENTER[0];
                if (configMapCenterLonInput) configMapCenterLonInput.value = MAP_DEFAULT_CENTER[1];
                if (configMapZoomInput) configMapZoomInput.value = MAP_DEFAULT_ZOOM;
                if (configBboxMarginInput) configBboxMarginInput.value = BOUNDING_BOX_MARGIN_PERCENT;
                if (configPoiListLimitInput) configPoiListLimitInput.value = POI_LIST_LIMIT;
                if (configOverpassTimeoutInput) configOverpassTimeoutInput.value = OVERPASS_TIMEOUT;
                if (configOverpassEndpointInput) configOverpassEndpointInput.value = OVERPASS_API_ENDPOINT;
                if (configRouteColorInput) configRouteColorInput.value = ROUTE_COLOR;
            } catch (e) {
                console.error("Erreur chargement settings:", e);
                if (configStatus) configStatus.innerHTML = `<p class="error">Erreur chargement paramètres: ${e.message}</p>`;
                BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100; // Recalculer au cas où
            }
        }

        function saveSettings() {
            if (!configPanel || !configStatus) return;
            configStatus.innerHTML = '<p class="loading">Sauvegarde en cours...</p>';
            try {
                const newOrsKey = configOrsApiKeyInput.value.trim();
                const newGeminiKey = configGeminiApiKeyInput.value.trim();
                const newWeatherKey = configWeatherApiKeyInput.value.trim();
                const newCenterLat = parseFloat(configMapCenterLatInput.value);
                const newCenterLon = parseFloat(configMapCenterLonInput.value);
                const newZoom = parseInt(configMapZoomInput.value, 10);
                const newBboxMarginPercent = parseInt(configBboxMarginInput.value, 10);
                const newPoiListLimit = parseInt(configPoiListLimitInput.value, 10);
                const newOverpassTimeout = parseInt(configOverpassTimeoutInput.value, 10);
                const newOverpassEndpoint = configOverpassEndpointInput.value.trim();
                const newRouteColor = configRouteColorInput.value;

                if (isNaN(newCenterLat) || isNaN(newCenterLon) || isNaN(newZoom) || isNaN(newBboxMarginPercent) || isNaN(newPoiListLimit) || isNaN(newOverpassTimeout) || !newOverpassEndpoint) {
                    throw new Error("Valeurs numériques invalides ou endpoint Overpass manquant.");
                }

                localStorage.setItem('orsApiKey', newOrsKey);
                localStorage.setItem('geminiApiKey', newGeminiKey);
                localStorage.setItem('weatherApiKey', newWeatherKey);

                localStorage.setItem('mapCenterLat', newCenterLat.toString());
                localStorage.setItem('mapCenterLon', newCenterLon.toString());
                localStorage.setItem('mapZoom', newZoom.toString());
                localStorage.setItem('bboxMarginPercent', newBboxMarginPercent.toString());
                localStorage.setItem('poiListLimit', newPoiListLimit.toString());
                localStorage.setItem('overpassTimeout', newOverpassTimeout.toString());
                localStorage.setItem('overpassEndpoint', newOverpassEndpoint);
                localStorage.setItem('routeColor', newRouteColor);

                ORS_API_KEY = newOrsKey;
                GEMINI_API_KEY = newGeminiKey;
                WEATHER_API_KEY = newWeatherKey;

                MAP_DEFAULT_CENTER = [newCenterLat, newCenterLon];
                MAP_DEFAULT_ZOOM = newZoom;
                BOUNDING_BOX_MARGIN_PERCENT = newBboxMarginPercent;
                POI_LIST_LIMIT = newPoiListLimit;
                OVERPASS_TIMEOUT = newOverpassTimeout;
                OVERPASS_API_ENDPOINT = newOverpassEndpoint;
                ROUTE_COLOR = newRouteColor;
                BOUNDING_BOX_MARGIN = BOUNDING_BOX_MARGIN_PERCENT / 100;

                if (GEMINI_API_KEY) {
                    GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                } else {
                    GEMINI_API_URL = '';
                }

                configStatus.innerHTML = '<p class="success">Paramètres enregistrés avec succès !</p>';

                if (map) map.setView(MAP_DEFAULT_CENTER, MAP_DEFAULT_ZOOM);
            } catch (e) {
                console.error("Erreur sauvegarde settings:", e);
                configStatus.innerHTML = `<p class="error">Erreur sauvegarde: ${e.message}</p>`;
            }
        }

        function toggleConfigPanel() {
            if (configPanel) configPanel.classList.toggle('visible');
        }

        // ########################################################################
        // ### GÉOLOCALISATION UTILISATEUR
        // ########################################################################
        async function handleLocateMe() {
            if (!navigator.geolocation) {
                alert("Votre navigateur ne supporte pas la géolocalisation.");
                return;
            }
            if (!locateMeBtn) return; // Sécurité
            locateMeBtn.disabled = true;
            locateMeBtn.classList.add('loading');
            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, timeout: 10000 });
                });
                const { latitude, longitude } = position.coords;

                // Tente de remplir le champ 'Départ' en priorité, sinon 'Arrivée'
                if (startInput.value.trim() === '') {
                    startInput.value = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
                } else if (endInput.value.trim() === '') {
                    endInput.value = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
                } else {
                     startInput.value = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
                     alert("Position actuelle ajoutée au champ 'Départ'.");
                }

                if (map) map.setView([latitude, longitude], 13);

            } catch (error) {
                console.error("Erreur géolocalisation:", error);
                let message = "Impossible de vous localiser.";
                if (error.code === error.PERMISSION_DENIED) {
                    message = "Vous avez refusé la permission de géolocalisation.";
                } else if (error.code === error.POSITION_UNAVAILABLE) {
                    message = "Information de localisation non disponible.";
                } else if (error.code === error.TIMEOUT) {
                    message = "La demande de géolocalisation a expiré.";
                }
                 alert(message);
            } finally {
                locateMeBtn.disabled = false;
                locateMeBtn.classList.remove('loading');
            }
        }

        // ########################################################################
        // ### FONCTION PRINCIPALE DE RECHERCHE DE POI
        // ########################################################################
        async function handlePlanning() {
            clearPreviousResults();
            planBtn.disabled = true;
            planBtn.classList.add('loading');

            try {
                const startAddress = startInput.value.trim();
                const endAddress = endInput.value.trim();
                const interests = interestsInput.value.trim();
                if (!startAddress || !endAddress) {
                    throw new Error("Veuillez renseigner au moins Départ et Arrivée.");
                }
                 if (!interests) {
                     summaryDiv.innerHTML = '<p class="warning">Aucun intérêt spécifié, la recherche de POI risque d\'être très large. Vous pouvez affiner avec les filtres.</p>';
                }

                summaryDiv.innerHTML += '<p class="info">Calcul de la zone de recherche...</p>';
                const boundingBox = await getBoundingBox(startAddress, endAddress);
                if (!boundingBox) return;

                summaryDiv.innerHTML += '<p class="info">Génération de la requête Overpass via IA...</p>';
                const overpassQuery = await generateOverpassQueryFromAI(interests, boundingBox);

                summaryDiv.innerHTML += '<p class="info">Recherche des Points d\'Intérêt via Overpass...</p>';
                const foundPois = await fetchPoisFromOverpass(overpassQuery);
                fullPoiList = foundPois;

                if (!foundPois || foundPois.length === 0) {
                    poiListDiv.innerHTML = '<p class="warning">Aucun POI trouvé pour ces critères dans cette zone. Essayez d\'élargir vos intérêts ou la zone.</p>';
                    updatePoiCount(0, 0);
                    return;
                }

                summaryDiv.innerHTML += `<p class="success">${foundPois.length} POI potentiels trouvés dans la zone. Filtrez et sélectionnez ci-dessous.</p>`;
                applyPoiFilters();

            } catch (error) {
                 console.error("Erreur dans handlePlanning:", error);
                 const errorHtml = `<p class="error">Erreur planification: ${error.message}</p>`;
                 summaryDiv.innerHTML = errorHtml;
                 poiListDiv.innerHTML = errorHtml;
                 updatePoiCount(0, 0);
            } finally {
                planBtn.disabled = false;
                planBtn.classList.remove('loading');
            }
        }

        // ########################################################################
        // ### APPLICATION DES FILTRES POI ET AFFICHAGE
        // ########################################################################
        function applyPoiFilters() {
            if (!poiListDiv) return;
             poiListDiv.innerHTML = '<p class="loading">Filtrage des POI...</p>';

             if (!Array.isArray(fullPoiList)) {
                 console.warn("applyPoiFilters: fullPoiList n'est pas un tableau.");
                 fullPoiList = [];
             }

            const checkedFiltersValues = Array.from(poiFilterCheckboxes)
                                            .filter(cb => cb.checked)
                                            .map(cb => cb.value);

            if (checkedFiltersValues.length === 0) {
                displayPoisAndEnableSelection([]);
                return;
            }

             const keywordGroups = checkedFiltersValues.map(filterString =>
                 filterString.split(',').map(s => s.trim().toLowerCase()).filter(Boolean)
             );
             const allKeywords = [...new Set(keywordGroups.flat())];

             const matchedPois = fullPoiList.filter(poi => {
                 if (!poi || !poi.tags) return false;
                 const tagString = Object.entries(poi.tags)
                                     .map(([key, value]) => `${key.toLowerCase()} ${value.toLowerCase()}`)
                                     .join(' ');
                 return allKeywords.some(keyword => tagString.includes(keyword));
             });

            displayPoisAndEnableSelection(matchedPois);
        }

        function displayPoisAndEnableSelection(poisToDisplay) {
            poiListDiv.innerHTML = '';
            if (poiMarkerClusterGroup) poiMarkerClusterGroup.clearLayers(); // Vérifie existence
            poiMarkers = [];
            displayedPoiCount = 0;
            currentFilteredPoiList = poisToDisplay;

            if (!Array.isArray(currentFilteredPoiList)) {
                 console.error("displayPoisAndEnableSelection: poisToDisplay n'est pas un tableau.");
                 currentFilteredPoiList = [];
             }

            if (currentFilteredPoiList.length === 0) {
                if (fullPoiList.length > 0) {
                     poiListDiv.innerHTML = '<p class="info">Aucun POI ne correspond aux filtres actifs.</p>';
                } else {
                     if (!poiListDiv.querySelector('.error')) {
                         poiListDiv.innerHTML = '<p class="info">Aucun POI à afficher.</p>';
                    }
                }
                if (loadMoreBtn) loadMoreBtn.style.display = 'none';
                updatePoiCount(0, currentFilteredPoiList.length);
                if (calculateSelectedRouteBtn) calculateSelectedRouteBtn.style.display = 'none';
                return;
            }

            createAllPoiMarkers(currentFilteredPoiList);
            displayMorePois();
            togglePoiLayerVisibility();
            if (calculateSelectedRouteBtn) calculateSelectedRouteBtn.style.display = 'block';
        }

        function createAllPoiMarkers(poiList) {
             const markersToAdd = [];
             poiMarkers = [];

             poiList.forEach(poi => {
                  try {
                      if (!poi || !poi.coordinates || typeof poi.coordinates[0] !== 'number' || typeof poi.coordinates[1] !== 'number') {
                          console.warn("POI invalide ou sans coordonnées:", poi);
                          return;
                      }

                      const isSelected = selectedPois.some(sp => sp.id === poi.id);
                      const marker = L.marker([poi.coordinates[1], poi.coordinates[0]], {
                           icon: isSelected ? selectedIcon : defaultIcon
                      });

                      let ohInfo = '';
                      if (poi.tags?.opening_hours) {
                           ohInfo = `<br><small title="${poi.tags.opening_hours}">Horaires: ${poi.tags.opening_hours.substring(0, 30)}${poi.tags.opening_hours.length > 30 ? '...' : ''}</small>`;
                      }
                      let websiteInfo = '';
                       if (poi.tags?.website) {
                           websiteInfo = `<br><small><a href="${poi.tags.website}" target="_blank" rel="noopener noreferrer">Site web</a></small>`;
                       }

                      let popupContent = `<b>${poi.name || '[Sans nom]'}</b><br><small>Type: ${poi.tags?.amenity || poi.tags?.leisure || poi.tags?.historic || poi.tags?.tourism || poi.type}</small>${ohInfo}${websiteInfo}<br><small>ID: ${poi.id}</small>`;
                      marker.bindPopup(popupContent);
                      marker.poiData = poi;
                      marker.on('click', (e) => { togglePoiSelection(null, e.target); });
                      markersToAdd.push(marker);
                  } catch (e) { console.error("Erreur création marqueur pour POI", poi?.id, e); }
             });

             if (poiMarkerClusterGroup) { // Vérifie que le groupe existe
                poiMarkerClusterGroup.addLayers(markersToAdd);
                poiMarkers = markersToAdd;

                if (poiMarkers.length > 0 && map && map.hasLayer(poiMarkerClusterGroup)) {
                    try {
                         const bounds = poiMarkerClusterGroup.getBounds();
                         if (bounds.isValid()) {
                             map.fitBounds(bounds.pad(0.1));
                         }
                    } catch (e) { console.warn("Impossible d'ajuster la carte aux limites des POI.", e); }
                }
            } else {
                 console.error("poiMarkerClusterGroup n'est pas initialisé lors de la création des marqueurs.");
            }
       }


        function displayMorePois() {
            const sourceList = currentFilteredPoiList;
            const isInitialDisplay = (displayedPoiCount === 0);
            const startIndex = displayedPoiCount;
            const endIndex = Math.min(startIndex + POI_LIST_LIMIT, sourceList.length);

            if (startIndex >= sourceList.length && !isInitialDisplay) {
                if (loadMoreBtn) loadMoreBtn.style.display = 'none';
                return;
            }

            const listFragment = document.createDocumentFragment();

            for (let i = startIndex; i < endIndex; i++) {
                const poi = sourceList[i];
                if (!poi) continue;

                const poiDiv = document.createElement('div');
                poiDiv.classList.add('poi-item');
                if (selectedPois.some(sp => sp.id === poi.id)) poiDiv.classList.add('selected');

                 const displayName = poi.name || `[${poi.tags?.amenity || poi.tags?.leisure || poi.tags?.historic || poi.type || 'POI'}]`;
                 poiDiv.textContent = displayName;

                 let titleText = `ID: ${poi.id}`;
                 const mainTagKey = Object.keys(poi.tags || {}).find(k => ['amenity', 'leisure', 'historic', 'tourism', 'shop', 'natural', 'craft'].includes(k));
                 if(mainTagKey) titleText += ` | ${mainTagKey}=${poi.tags[mainTagKey]}`;
                 if (poi.tags?.opening_hours) titleText += ` | Horaires: ${poi.tags.opening_hours}`;
                 poiDiv.title = titleText;

                poiDiv.dataset.poiId = poi.id;
                poiDiv.addEventListener('click', togglePoiSelection);
                listFragment.appendChild(poiDiv);
            }

             if (isInitialDisplay && poiListDiv.querySelector('.loading, .info, .error')) {
                 poiListDiv.innerHTML = '';
             }

            poiListDiv.appendChild(listFragment);
            displayedPoiCount = endIndex;

            updatePoiCount(displayedPoiCount, sourceList.length);

            if (loadMoreBtn) loadMoreBtn.style.display = (displayedPoiCount < sourceList.length) ? 'inline-block' : 'none';
        }

        function updatePoiCount(displayedInList, totalFiltered) {
            if (poiCountSpan) {
                poiCountSpan.textContent = `(${displayedInList} / ${totalFiltered} filtrés / ${Math.max(0, fullPoiList.length)} total)`;
            }
        }

        function togglePoiLayerVisibility() {
            if (!map || !poiMarkerClusterGroup || !togglePoiLayerCheckbox) return;
            if (togglePoiLayerCheckbox.checked) {
                if (!map.hasLayer(poiMarkerClusterGroup)) {
                    map.addLayer(poiMarkerClusterGroup);
                }
            } else {
                if (map.hasLayer(poiMarkerClusterGroup)) {
                    map.removeLayer(poiMarkerClusterGroup);
                }
            }
        }

        // ########################################################################
        // ### ITINÉRAIRE FINAL AVEC POI SÉLECTIONNÉS
        // ########################################################################
        async function handleRouteCalculationFinal() {
            if (!selectedPois || selectedPois.length === 0) {
                summaryDiv.innerHTML = '<p class="warning">Veuillez sélectionner au moins un Point d\'Intérêt dans la liste pour calculer l\'itinéraire.</p>';
                return;
            }
            calculateSelectedRouteBtn.disabled = true;
            calculateSelectedRouteBtn.classList.add('loading');
            clearRouteLayer();
            summaryDiv.innerHTML = '';
            instructionsDiv.innerHTML = '';
            weatherDisplayDiv.innerHTML = '';

            try {
                summaryDiv.innerHTML = '<p class="info">Calcul de l’itinéraire via les POI sélectionnés...</p>';

                const startAddress = startInput.value.trim();
                const endAddress = endInput.value.trim();
                const profile = profileSelect.value;
                const routePreference = routePrefSelect.value;

                 if (!startAddress || !endAddress) {
                     throw new Error("Les adresses de Départ et d'Arrivée sont nécessaires pour le calcul final.");
                 }


                const routeData = await getRouteFromOrs(startAddress, endAddress, selectedPois, profile, routePreference);

                if (!routeData?.features?.[0]) {
                     throw new Error("Impossible d'obtenir les données d'itinéraire depuis OpenRouteService.");
                }

                drawRoute(routeData);
                displayRouteInstructions(routeData);

                 const aiSummaryPromise = getAiRouteSummary(interestsInput.value, routeData, tripDaysCount)
                     .then(summaryText => {
                          const summaryContainer = document.createElement('div');
                          summaryContainer.innerHTML = summaryText;
                          summaryDiv.prepend(summaryContainer);
                     })
                     .catch(err => {
                          console.warn("Erreur résumé IA:", err);
                          summaryDiv.innerHTML += `<p class="warning">Impossible de générer le résumé IA: ${err.message}</p>`;
                     });


                const weatherPromises = [];
                if (WEATHER_API_KEY) {
                     weatherDisplayDiv.innerHTML = '<h5>Météo Actuelle</h5><p class="loading">Chargement météo...</p>';
                     try {
                          const startCoordsPromise = getOrsCoordinates(startAddress)
                              .then(([lon, lat]) => fetchAndShowWeather(lat, lon, `Départ (${startAddress.substring(0,20)}...)`))
                              .catch(e => console.warn("Impossible de récupérer météo Départ:", e));
                           weatherPromises.push(startCoordsPromise);

                          const endCoordsPromise = getOrsCoordinates(endAddress)
                              .then(([lon, lat]) => fetchAndShowWeather(lat, lon, `Arrivée (${endAddress.substring(0,20)}...)`))
                              .catch(e => console.warn("Impossible de récupérer météo Arrivée:", e));
                           weatherPromises.push(endCoordsPromise);

                           Promise.allSettled(weatherPromises).then(() => {
                                const loadingMsg = weatherDisplayDiv.querySelector('p.loading');
                                if (loadingMsg) loadingMsg.remove();
                                if (weatherDisplayDiv.children.length <= 1 && !weatherDisplayDiv.querySelector('.weather-location')) {
                                     weatherDisplayDiv.innerHTML += '<p class="info">Données météo non disponibles.</p>';
                                }
                           });

                     } catch (e) {
                          console.error("Erreur lors de la préparation des appels météo:", e);
                           weatherDisplayDiv.innerHTML = `<p class="error">Erreur chargement météo: ${e.message}</p>`;
                     }
                 } else {
                      weatherDisplayDiv.innerHTML = '';
                 }

                 if (routeLayer) {
                     exportGpxBtn.style.display = 'block';
                 }

                 await aiSummaryPromise;

            } catch (error) {
                console.error("Erreur dans handleRouteCalculationFinal:", error);
                summaryDiv.innerHTML = `<p class="error">Erreur calcul itinéraire: ${error.message}</p>`;
                 clearRouteLayer();
            } finally {
                calculateSelectedRouteBtn.disabled = false;
                calculateSelectedRouteBtn.classList.remove('loading');
            }
        }

        function togglePoiSelection(e, markerRef) {
            let poiId, itemEl, targetMarker;

            if (markerRef) {
                poiId = markerRef.poiData?.id;
                 if (!poiId) { console.warn("Marqueur sans poiData.id cliqué"); return; }
                targetMarker = markerRef;
                 itemEl = poiListDiv.querySelector(`.poi-item[data-poi-id="${poiId}"]`);
            } else if (e && e.currentTarget) {
                itemEl = e.currentTarget;
                poiId = itemEl.dataset.poiId;
                 if (!poiId) { console.warn("Élément de liste sans data-poi-id cliqué"); return; }
                 targetMarker = poiMarkers.find(m => m.poiData && m.poiData.id == poiId);
            } else {
                 console.warn("togglePoiSelection appelé sans référence valide");
                 return;
            }

             const poiIdStr = String(poiId);
            const poiIndexInSelected = selectedPois.findIndex(p => String(p.id) === poiIdStr);

            if (poiIndexInSelected >= 0) {
                selectedPois.splice(poiIndexInSelected, 1);
                itemEl?.classList.remove('selected');
                if (targetMarker) targetMarker.setIcon(defaultIcon);
            } else {
                 const poiData = currentFilteredPoiList.find(p => String(p.id) === poiIdStr) || fullPoiList.find(p => String(p.id) === poiIdStr);

                if (poiData) {
                    selectedPois.push(poiData);
                    itemEl?.classList.add('selected');
                    if (targetMarker) targetMarker.setIcon(selectedIcon);
                } else {
                     console.warn(`POI avec id ${poiIdStr} non trouvé dans les listes pour sélection.`);
                }
            }
        }

        // ########################################################################
        // ### APPELS API (ORS, GEMINI, OVERPASS)
        // ########################################################################
        async function getOrsCoordinates(address) {
              if (!address) return null;
              if (!ORS_API_KEY) throw new Error("Clé API OpenRouteService manquante.");

              const latLonMatch = address.match(/^(-?\d+(\.\d+)?)[,\s]+(-?\d+(\.\d+)?)$/);
              if (latLonMatch) {
                   const lat = parseFloat(latLonMatch[1]);
                   const lon = parseFloat(latLonMatch[3]);
                   if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                       console.log(`Utilisation directe des coordonnées: [${lon}, ${lat}] pour "${address}"`);
                       return [lon, lat]; // ORS utilise [lon, lat]
                   } else {
                       console.warn(`Coordonnées invalides fournies: ${address}`);
                   }
              }

              const url = `https://api.openrouteservice.org/geocode/search?api_key=${ORS_API_KEY}&text=${encodeURIComponent(address)}&size=1`;
              try {
                   console.log(`Géocodage ORS pour: "${address}"`);
                   const response = await fetch(url);
                   if (!response.ok) {
                       console.warn(`ORS Search a échoué (${response.status}), tentative avec Autocomplete...`);
                       const autoUrl = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(address)}&size=1`;
                       const autoResp = await fetch(autoUrl);
                       if (!autoResp.ok) {
                           let errorMsg = `Erreur Géocodage ORS (${response.status}/${autoResp.status}) pour "${address}"`;
                           try { errorMsg += ` Détail: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){}
                           throw new Error(errorMsg);
                       }
                       const autoData = await autoResp.json();
                       if (!autoData.features || autoData.features.length === 0) {
                           throw new Error(`Adresse non trouvée par ORS (Search & Autocomplete): "${address}"`);
                       }
                       console.log(`Utilisation résultat Autocomplete pour "${address}"`);
                       return autoData.features[0].geometry.coordinates; // [lon, lat]
                   }
                   const data = await response.json();
                   if (!data.features || data.features.length === 0) {
                       throw new Error(`Adresse non trouvée par ORS Search: "${address}"`);
                   }
                    console.log(`Utilisation résultat Search pour "${address}"`);
                   return data.features[0].geometry.coordinates; // [lon, lat]
              } catch (error) {
                   console.error("Erreur dans getOrsCoordinates:", error);
                   throw error;
              }
         }


        async function getBoundingBox(startAddress, endAddress) {
            try {
                const startCoords = await getOrsCoordinates(startAddress);
                const endCoords = await getOrsCoordinates(endAddress);

                const [lon1, lat1] = startCoords;
                const [lon2, lat2] = endCoords;

                const marginLat = Math.abs(lat1 - lat2) * BOUNDING_BOX_MARGIN;
                const marginLon = Math.abs(lon1 - lon2) * BOUNDING_BOX_MARGIN;
                 const minMargin = 0.05;

                const south = Math.max(-90, Math.min(lat1, lat2) - Math.max(marginLat, minMargin));
                const north = Math.min(90, Math.max(lat1, lat2) + Math.max(marginLat, minMargin));
                const west = Math.max(-180, Math.min(lon1, lon2) - Math.max(marginLon, minMargin));
                const east = Math.min(180, Math.max(lon1, lon2) + Math.max(marginLon, minMargin));

                console.log("Bounding Box calculée:", { south, west, north, east });
                return { south, west, north, east };
            } catch (error) {
                summaryDiv.innerHTML = `<p class="error">Erreur calcul zone: ${error.message}</p>`;
                 poiListDiv.innerHTML = `<p class="error">Erreur calcul zone: ${error.message}</p>`;
                throw new Error(`Impossible de définir la zone de recherche (${error.message})`);
            }
        }

        async function generateOverpassQueryFromAI(interests, boundingBox) {
             if (!boundingBox || typeof boundingBox.south !== 'number') {
                 throw new Error("BBox invalide pour l'IA.");
             }
             const bboxString = `${boundingBox.south.toFixed(6)},${boundingBox.west.toFixed(6)},${boundingBox.north.toFixed(6)},${boundingBox.east.toFixed(6)}`;

             const prompt = `
                  Tu es un expert mondial en données OpenStreetMap (OSM) et dans le langage de requête Overpass QL.
                  L'utilisateur souhaite planifier un itinéraire et a décrit ses intérêts.
                  Ta tâche est de générer une requête Overpass QL complète et optimisée pour trouver des points d'intérêt (POI) pertinents (nodes, ways, relations) dans une zone géographique donnée.

                  Intérêts de l'utilisateur: "${interests}"

                  Zone géographique (bounding box au format south, west, north, east): ${bboxString}

                  Instructions pour la requête Overpass QL:
                  1.  **Format de Sortie Obligatoire:** Commence par \`[out:json][timeout:${OVERPASS_TIMEOUT}];\` et termine par \`out center;\`.
                  2.  **Application de la Zone:** Applique le bounding box \`${bboxString}\` DIRECTEMENT après le tag/filtre, SANS parenthèses supplémentaires autour des coordonnées. Syntaxe CORRECTE : \`type[tag](south,west,north,east);\`. Exemple: \`node["amenity"="restaurant"](${bboxString});\`.
                  3.  **Pertinence des Tags:** Traduis les 'intérêts' en tags OSM pertinents. Concentre-toi sur :
                      * **Vues/Paysages:** \`tourism=viewpoint\`, \`natural=peak\`, \`man_made=lighthouse\`, zones \`natural=wood\`, \`natural=water\`, \`natural=heath\`, \`natural=grassland\`, \`highway=passing_place\` (si vue).
                      * **Parcs/Nature:** \`leisure=park\`, \`leisure=nature_reserve\`, \`boundary=national_park\`, \`boundary=protected_area\`, \`leisure=garden\`.
                      * **Terroir/Marchés:** \`amenity=marketplace\`, \`shop=farm\`, \`shop=deli\`, \`shop=cheese\`, \`shop=wine\`, \`craft=brewery\`, \`craft=pottery\`, \`amenity=restaurant\` (avec cuisine locale si possible, mais difficile à tagger).
                      * **Oiseaux/Faune:** \`leisure=bird_hide\`, \`tourism=attraction[attraction=animal]\`, zones \`natural=wetland\`, \`natural=scree\`.
                      * **Histoire/Culture:** \`historic=*\` (castle, ruins, monument, archaeological_site, memorial, church), \`tourism=museum\`, \`tourism=attraction\`, \`amenity=theatre\`, \`amenity=arts_centre\`.
                      * **Eau/Plages:** \`natural=water\`, \`natural=coastline\`, \`natural=beach\`, \`natural=spring\`, \`waterway=waterfall\`, \`natural=bay\`.
                      * **Villages:** Chercher \`place=village\` ou \`place=hamlet\` et inclure les éléments historiques/touristiques à l'intérieur ou très proches.
                  4.  **Structure de la Requête:** Utilise une union \`( ... );\` pour regrouper les différentes recherches. Exemple: \`( node["tourism"="viewpoint"](${bboxString}); way["leisure"="park"](${bboxString}); );\`. Point-virgule sépare chaque clause DANS l'union.
                  5.  **Performance:** Cible les tags spécifiques. Évite les requêtes trop génériques comme \`["natural"]\` seul. Utilise \`node\`, \`way\`, \`relation\` de manière appropriée. Pour les zones (way/relation), demande \`out center;\` pour obtenir un point central. Ne cherche pas \`relation\` sauf pour \`boundary=*\`, \`type=route\` (sentiers) ou zones complexes si nécessaire.
                  6.  **Nommage:** Priorise les éléments ayant un tag \`name\` mais inclus aussi ceux sans nom si le tag principal est très descriptif (ex: viewpoint).
                  7.  **Syntaxe Strict des Filtres:** Utilise **UNIQUEMENT** des correspondances exactes avec '=' (ex: \`["amenity"="restaurant"]\`), des vérifications d'existence de clé (ex: \`["historic"]\`) ou des non-égalités \`!=\` (ex: \`["historic"!="no"]\`). **N'utilise JAMAIS l'opérateur regex '~' ou de regex complexe**.
                  8.  **Sortie Brute:** Ne génère QUE la requête Overpass QL valide. Pas de commentaires dans la requête, pas d'explications avant/après, pas de formatage Markdown (\`\`\`). Commence directement par \`[out:json]...\`.

                  Requête Overpass QL générée:
             `;

             try {
                  console.log("Prompt Gemini (Query Gen) avec BBox:", bboxString);
                  const response = await fetch(GEMINI_API_URL, {
                       method: 'POST', headers: { 'Content-Type': 'application/json' },
                       body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: 0.3, topP: 0.95 } })
                  });
                  if (!response.ok) {
                       let errorMsg = `Erreur API Gemini (${response.status}) Query Gen.`; try { errorMsg += ` Détail: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){} throw new Error(errorMsg);
                  }
                  const data = await response.json();
                  if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                       const safetyFeedback = data.promptFeedback?.safetyRatings;
                       if (safetyFeedback && safetyFeedback.some(r => r.blocked)) {
                            console.error("Réponse Gemini bloquée pour des raisons de sécurité:", safetyFeedback);
                            throw new Error("L'IA a refusé de générer la requête (possible contenu inapproprié dans les intérêts?).");
                       }
                       console.error("Réponse Gemini (Query Gen) inattendue:", JSON.stringify(data)); throw new Error("Structure réponse IA inattendue (Query Gen).");
                  }
                  const generatedQuery = data.candidates[0].content.parts[0].text;

                  const cleanedQuery = generatedQuery.replace(/```(ql|overpass)?\s*|\s*```/g, '').trim();
                  if (!cleanedQuery.startsWith('[out:json]') || !cleanedQuery.includes('out center;')) {
                       console.error("Requête générée invalide ou vide:", cleanedQuery);
                       if (cleanedQuery.length < 50 && cleanedQuery.toLowerCase().includes("prompt")) {
                           throw new Error("L'IA a répondu au lieu de générer la requête (vérifiez le prompt envoyé).");
                       } else {
                            throw new Error("L'IA n'a pas généré une requête Overpass QL valide (format incorrect ou vide).");
                       }
                  }
                  if (cleanedQuery.match(/~|\[".*?"~".*?"\]/)) {
                        console.error("Erreur critique: L'IA a utilisé un opérateur regex interdit ('~' ou similar) !", cleanedQuery);
                        throw new Error("Erreur de syntaxe générée par l'IA (opérateur regex interdit utilisé). Modifiez vos intérêts ou réessayez.");
                  }
                  if (!cleanedQuery.includes(bboxString.substring(0, 10))) {
                       console.error("Erreur critique: La BBox semble manquante dans la requête générée !", cleanedQuery);
                       throw new Error("Erreur de génération IA : la zone géographique (bbox) est manquante dans la requête Overpass.");
                  }

                  console.log("Requête Overpass générée par IA (nettoyée):", cleanedQuery);
                  return cleanedQuery;
             } catch (error) {
                  console.error("Erreur appel IA (Query Gen):", error);
                  throw new Error(`Génération requête IA échouée: ${error.message}`);
             }
        }

        async function fetchPoisFromOverpass(query) {
            if (!OVERPASS_API_ENDPOINT) throw new Error("Endpoint Overpass non configuré.");
            if (!query) {
                console.warn("fetchPoisFromOverpass appelée sans requête.");
                return [];
            }

            poiListDiv.innerHTML = `<p class="loading">Recherche POI via Overpass (${OVERPASS_TIMEOUT}s max)...</p>`;
             updatePoiCount(0, 0);

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                     controller.abort();
                     console.warn(`Requête Overpass annulée après ${OVERPASS_TIMEOUT} secondes.`);
                }, OVERPASS_TIMEOUT * 1000);

                console.log("Envoi requête Overpass:", query);

                const response = await fetch(OVERPASS_API_ENDPOINT, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(query)}`,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                        'Accept': 'application/json'
                    },
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                     let errorText = `Erreur Overpass (${response.status})`;
                     try {
                          const errorBody = await response.text();
                           if (errorBody.includes("runtime error") || errorBody.includes("Query timed out") || errorBody.includes("query complexity")) {
                                errorText += `: ${errorBody.substring(0, 200)}... (Probablement requête trop complexe ou timeout serveur)`;
                           } else {
                                errorText += `: ${errorBody.substring(0, 200)}...`;
                           }
                     } catch(e) { /* Ignore si lecture échoue */ }
                    throw new Error(errorText);
                }

                 const data = await response.json();

                 if (!data || !Array.isArray(data.elements)) {
                      throw new Error("Réponse Overpass invalide ou ne contient pas 'elements'.");
                 }

                 const pois = data.elements.map(el => {
                     try {
                          const lon = el.lon ?? el.center?.lon;
                          const lat = el.lat ?? el.center?.lat;

                          if (typeof lon !== 'number' || typeof lat !== 'number') return null;

                          let name = el.tags?.name || el.tags?.['name:fr'] || el.tags?.alt_name;
                          if (!name) {
                               const mainTagKey = Object.keys(el.tags || {}).find(k => ['amenity', 'leisure', 'historic', 'tourism', 'shop', 'natural', 'craft', 'place'].includes(k));
                               if (mainTagKey && el.tags[mainTagKey]) {
                                    name = `[${el.tags[mainTagKey].replace('_',' ')}]`;
                               } else {
                                    name = `[${el.type} #${el.id}]`;
                               }
                          }

                          const mainTags = {};
                          if (el.tags) {
                               for (const key in el.tags) {
                                    if (['name', 'name:fr', 'alt_name', 'website', 'opening_hours', 'amenity', 'leisure', 'historic', 'tourism', 'shop', 'natural', 'craft', 'place', 'ele', 'description'].includes(key)) {
                                         mainTags[key] = el.tags[key];
                                    }
                               }
                          }

                          return {
                               id: el.id,
                               type: el.type,
                               name: name,
                               coordinates: [lon, lat], // [lon, lat]
                               tags: mainTags
                          };
                     } catch (mapError) {
                          console.warn("Erreur traitement élément Overpass:", el?.id, mapError);
                          return null;
                     }
                }).filter(Boolean);

                 const uniquePois = Array.from(new Map(pois.map(p => [p.id, p])).values());

                console.log(`${uniquePois.length} POIs uniques extraits.`);
                return uniquePois;

            } catch (error) {
                 if (error.name === 'AbortError') {
                     throw new Error(`La requête Overpass a dépassé le délai de ${OVERPASS_TIMEOUT} secondes.`);
                 }
                 console.error("Erreur dans fetchPoisFromOverpass:", error);
                 throw error;
            }
        }

        async function getRouteFromOrs(startAddress, endAddress, waypoints, profile, routePreference) {
            if (!ORS_API_KEY) {
                 throw new Error("Clé API ORS manquante pour le calcul d'itinéraire.");
            }
            summaryDiv.innerHTML += '<p class="loading info">... géocodage départ/arrivée pour routage ...</p>';
            let startCoords, endCoords;
            try {
                 startCoords = await getOrsCoordinates(startAddress);
                 endCoords = await getOrsCoordinates(endAddress);
            } catch (geoError) {
                 throw new Error(`Erreur géocodage pour routage: ${geoError.message}`);
            }

            const validWaypoints = waypoints.filter(p => p && p.coordinates && typeof p.coordinates[0] === 'number' && typeof p.coordinates[1] === 'number');
             if (validWaypoints.length !== waypoints.length) {
                 console.warn("Certains POI sélectionnés avaient des coordonnées invalides et ont été ignorés pour le routage.");
             }
              if (validWaypoints.length === 0 && waypoints.length > 0) {
                  throw new Error("Aucun des POI sélectionnés n'a de coordonnées valides pour le routage.");
              }

            const allCoordinates = [startCoords, ...validWaypoints.map(p => p.coordinates), endCoords];

             let orsOptions = {};
             let orsPreference = 'recommended';

             if (profile === 'driving-car' || profile === 'driving-hgv') {
                 const avoidFeatures = [];
                 if (routePreference === 'AVOID_HIGHWAYS') avoidFeatures.push('highways');
                 if (routePreference === 'AVOID_TOLLS') avoidFeatures.push('tollways');
                 if (avoidFeatures.length > 0) orsOptions.avoid_features = avoidFeatures;

                 if (routePreference === 'SHORTEST') orsPreference = 'shortest';
                 else if (routePreference === 'FASTEST') orsPreference = 'fastest';
             } else if (profile === 'cycling-regular') {
                 orsPreference = 'recommended';
             } else if (profile === 'foot-walking') {
                 orsPreference = 'shortest';
             }

            const url = `https://api.openrouteservice.org/v2/directions/${profile}/geojson`;
            const body = {
                coordinates: allCoordinates,
                language: 'fr',
                instructions: true,
                instructions_format: "text",
                preference: orsPreference,
                units: "km"
            };
            if (Object.keys(orsOptions).length > 0) {
                body.options = orsOptions;
            }

             console.log("Appel ORS Directions avec:", JSON.stringify(body).substring(0, 500) + "...");
             summaryDiv.innerHTML += '<p class="loading info">... appel API routage OpenRouteService ...</p>';

             try {
                 const response = await fetch(url, {
                     method: 'POST',
                     body: JSON.stringify(body),
                     headers: {
                         'Authorization': ORS_API_KEY,
                         'Content-Type': 'application/json; charset=utf-8',
                         'Accept': 'application/json, application/geo+json, */*'
                     }
                 });

                 if (!response.ok) {
                     let errJson;
                     let errMsg = `Erreur Routage ORS (${response.status})`;
                     try {
                         errJson = await response.json();
                         errMsg += `: ${errJson?.error?.message || errJson?.error || response.statusText}`;
                         if (errJson?.error?.code === 2003) {
                             errMsg += ". Vérifiez que tous les POI sont accessibles par le mode de transport choisi.";
                         }
                     } catch { /* ignore json parsing error */ }
                     throw new Error(errMsg);
                 }

                 const routeData = await response.json();
                 if (!routeData || !routeData.features || routeData.features.length === 0 || !routeData.features[0].geometry) {
                     throw new Error("Réponse de routage ORS invalide ou incomplète.");
                 }

                 return routeData;
             } catch (error) {
                  console.error("Erreur dans getRouteFromOrs fetch:", error);
                  throw error;
             }
        }

        async function getAiRouteSummary(interests, routeData, nbJours) {
            if (!GEMINI_API_KEY || !GEMINI_API_URL) {
                 return "<p class='info'>Résumé IA non disponible (Clé API Gemini non configurée).</p>";
            }
            if (!routeData?.features?.[0]?.properties?.summary) {
                 return "<p class='warning'>Données itinéraire insuffisantes pour générer un résumé IA.</p>";
            }

            const summary = routeData.features[0].properties.summary;
             const distanceKm = (summary.distance).toFixed(1);
            const durationSec = summary.duration;
            let durationFormatted;
              if (durationSec < 3600) {
                  durationFormatted = `${Math.round(durationSec / 60)} minutes`;
              } else {
                  const hours = Math.floor(durationSec / 3600);
                  const minutes = Math.round((durationSec % 3600) / 60);
                  durationFormatted = `${hours}h ${minutes}min`;
              }

            let poiNames = selectedPois.map(p => p.name).filter(Boolean).join(', ');
            if (!poiNames) poiNames = "plusieurs points d'intérêt sélectionnés";

             const joursStr = nbJours > 1 ? `${nbJours} jours` : "une journée";
             const prompt = `
[SYSTEM]
Tu es un assistant de voyage concis et enthousiaste. Rédige un court paragraphe (environ 3-4 phrases MAXIMUM) EN FRANÇAIS pour résumer cet itinéraire.
Le voyage est prévu sur ${joursStr}.
Les intérêts principaux sont : "${interests || ' variés'}".
L'itinéraire passe par : ${poiNames}.
Distance totale : ${distanceKm} km. Durée de trajet estimée : ${durationFormatted}.

Mentionne brièvement comment l'itinéraire correspond aux intérêts. Si ${nbJours > 1}, suggère juste que cela permet de profiter des étapes sans détailler la répartition jour/jour.
Sois positif et donne envie de faire le voyage ! Ne répète pas exactement la distance/durée si ce n'est pas naturel.
[/SYSTEM]
Résumé :`;

            try {
                 const response = await fetch(GEMINI_API_URL, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         contents: [{ parts: [{ text: prompt }] }],
                         generationConfig: { temperature: 0.7, topP: 0.9, maxOutputTokens: 200 }
                     })
                 });
                 if (!response.ok) {
                     let errorMsg = `Erreur API Gemini (${response.status}) pour résumé.`; try { errorMsg += ` Détail: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){}
                      console.error(errorMsg);
                      return `<p class="warning">Le résumé IA n'a pas pu être généré (${response.status}).</p>`;
                 }
                 const data = await response.json();
                 const text = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

                 if (!text) {
                      console.warn("Réponse IA vide pour le résumé.");
                      return "<p class='info'>Le résumé IA n'a pas fourni de texte.</p>";
                 }
                 return `<p class="info">${text.replace(/\s+/g, ' ').trim()}</p>`;

            } catch (error) {
                 console.error("Impossible de générer le résumé IA:", error);
                 return `<p class="warning">Impossible de contacter l'IA pour le résumé: ${error.message}</p>`;
            }
        }

        // ########################################################################
        // ### AFFICHAGE ITINÉRAIRE SUR CARTE & INSTRUCTIONS
        // ########################################################################
        function drawRoute(routeData) {
            clearRouteLayer();

            routeLayer = L.geoJSON(routeData, {
                style: {
                    color: ROUTE_COLOR,
                    weight: 5,
                    opacity: 0.75
                },
                 onEachFeature: function (feature, layer) {
                     if (feature.properties && feature.properties.summary) {
                          const summary = feature.properties.summary;
                          const distanceKm = (summary.distance).toFixed(1);
                          const durationSec = summary.duration;
                          let durationFormatted;
                           if (durationSec < 3600) durationFormatted = `${Math.round(durationSec / 60)} min`;
                           else durationFormatted = `${Math.floor(durationSec / 3600)}h ${Math.round((durationSec % 3600) / 60)}min`;
                          layer.bindPopup(`<b>Itinéraire</b><br>Distance: ${distanceKm} km<br>Durée: ${durationFormatted}`);
                     }
                 }
            });

             if (map && routeLayer) {
                 routeLayer.addTo(map);
                 try {
                      const bounds = routeLayer.getBounds();
                      if(bounds.isValid()) {
                           map.fitBounds(bounds.pad(0.1));
                      }
                 } catch (e) { console.warn("Impossible d'ajuster la carte au tracé de l'itinéraire.", e); }
             } else {
                  console.error("Impossible d'ajouter le tracé à la carte.");
             }
        }

        function displayRouteInstructions(routeData) {
             if (!routeData?.features?.[0]?.properties?.segments) {
                 instructionsDiv.innerHTML = '<p class="info">Aucune instruction détaillée disponible pour cet itinéraire.</p>';
                 return;
             }

             const segments = routeData.features[0].properties.segments;
             const allSteps = segments.flatMap(seg => seg.steps || []);

             if (allSteps.length === 0) {
                 instructionsDiv.innerHTML = '<p class="info">Aucune instruction détaillée trouvée.</p>';
                 return;
             }

             let html = '<h4>Instructions Détaillées</h4><ol>';
             allSteps.forEach(step => {
                  let distanceStr;
                  if (step.distance < 1) distanceStr = `${(step.distance * 1000).toFixed(0)} m`;
                  else distanceStr = `${step.distance.toFixed(1)} km`;

                  let durationStr = '';
                  if (step.duration > 0) {
                       if (step.duration < 60) durationStr = ` (~${step.duration.toFixed(0)} s)`;
                       else durationStr = ` (~${Math.round(step.duration / 60)} min)`;
                  }

                   const instructionText = step.instruction || 'Continuer';
                   const li = document.createElement('li');
                   li.innerHTML = `<strong></strong> (${distanceStr}${durationStr})`;
                   li.querySelector('strong').textContent = instructionText; // Injection sûre
                   html += li.outerHTML;
             });
             html += '</ol>';
             instructionsDiv.innerHTML = html;
        }

        // ########################################################################
        // ### MÉTÉO
        // ########################################################################
        async function fetchAndShowWeather(lat, lon, label) {
             if (!WEATHER_API_KEY || !weatherDisplayDiv) return;

             const url = `${WEATHER_API_URL}?lat=${lat}&lon=${lon}&appid=${WEATHER_API_KEY}&units=metric&lang=fr`;

             try {
                  const response = await fetch(url);
                  if (!response.ok) {
                       console.warn(`Erreur API Météo (${response.status}) pour ${label}`);
                       weatherDisplayDiv.innerHTML += `
                           <div class="weather-location error">
                               <strong>${label}</strong>
                               <span>Impossible de charger la météo (${response.status})</span>
                           </div>`;
                       return;
                  }
                  const data = await response.json();

                  const cityName = data.name || 'Lieu inconnu';
                  const weatherDesc = data.weather?.[0]?.description ? data.weather[0].description.charAt(0).toUpperCase() + data.weather[0].description.slice(1) : 'Météo inconnue';
                  const temp = data.main?.temp?.toFixed(1) ?? '?';
                  const feelsLike = data.main?.feels_like?.toFixed(1) ?? '?';
                  const iconCode = data.weather?.[0]?.icon;
                  const iconUrl = iconCode ? `${WEATHER_ICON_URL}${iconCode}@2x.png` : null;

                 weatherDisplayDiv.innerHTML += `
                     <div class="weather-location">
                         <strong><i class="fa-solid fa-location-dot"></i> ${label} (${cityName})</strong>
                         <div class="weather-details">
                             ${iconUrl ? `<img src="${iconUrl}" alt="${weatherDesc}" title="${weatherDesc}">` : `<span><i class="fa-solid fa-question"></i></span>`}
                             <span><i class="fa-solid fa-temperature-half"></i> ${temp}°C</span>
                             <span>(Ressenti: ${feelsLike}°C)</span>
                             <span>- ${weatherDesc}</span>
                         </div>
                     </div>
                 `;

             } catch (e) {
                  console.error(`Erreur fetch Météo pour ${label}:`, e);
                  weatherDisplayDiv.innerHTML += `
                        <div class="weather-location error">
                            <strong>${label}</strong>
                            <span>Erreur chargement météo (${e.message})</span>
                        </div>`;
             }
        }

        // ########################################################################
        // ### EXPORT GPX
        // ########################################################################
        function exportGpx() {
            if (!routeLayer || typeof routeLayer.toGeoJSON !== 'function') {
                alert("Aucun itinéraire affiché à exporter en GPX.");
                return;
            }
            let geoJson;
              try {
                  geoJson = routeLayer.toGeoJSON();
              } catch(e) {
                   alert("Erreur lors de la conversion de l'itinéraire pour l'export GPX.");
                   console.error("Erreur routeLayer.toGeoJSON():", e);
                   return;
              }

              if (!geoJson || !geoJson.features || geoJson.features.length === 0 || !geoJson.features[0].geometry || !geoJson.features[0].geometry.coordinates) {
                   alert("Les données de l'itinéraire sont incomplètes ou invalides pour l'export GPX.");
                   console.error("GeoJSON invalide pour GPX:", geoJson);
                   return;
              }

              const now = new Date().toISOString();
              let gpx = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
 version="1.1" creator="PlanificateurItineraireIA">
 <metadata>
  <name>Itinéraire IA</name>
  <desc>Itinéraire généré le ${now} incluant les POI sélectionnés.</desc>
  <time>${now}</time>
 </metadata>
`;

              if (selectedPois && selectedPois.length > 0) {
                   selectedPois.forEach(poi => {
                        if (poi.coordinates && typeof poi.coordinates[1] === 'number' && typeof poi.coordinates[0] === 'number') {
                             const nameXmlSafe = (poi.name || `POI ${poi.id}`).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
                             gpx += ` <wpt lat="${poi.coordinates[1]}" lon="${poi.coordinates[0]}">
  <name>${nameXmlSafe}</name>
  <cmt>Type: ${poi.type}, ID: ${poi.id}</cmt>
  <sym>flag</sym> </wpt>\n`;
                        }
                   });
              }

              gpx += ` <trk>
  <name>Itinéraire Calculé</name>
  <trkseg>\n`;

              const coords = geoJson.features[0].geometry.coordinates;
              if (Array.isArray(coords) && coords.length > 0) {
                   coords.forEach(([lon, lat]) => {
                        if (typeof lat === 'number' && typeof lon === 'number') {
                           gpx += `  <trkpt lat="${lat}" lon="${lon}"></trkpt>\n`;
                        }
                   });
              }

              gpx += ` </trkseg>
 </trk>
</gpx>`;

            const blob = new Blob([gpx], { type: 'application/gpx+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
             const dateStr = now.substring(0, 10);
            a.download = `itineraire_ia_${dateStr}.gpx`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ########################################################################
        // ### UTILS
        // ########################################################################
        function clearPreviousResults() {
            summaryDiv.innerHTML = '';
            instructionsDiv.innerHTML = '';
            poiListDiv.innerHTML = 'Prêt à chercher des POI.';
            weatherDisplayDiv.innerHTML = '';
            fullPoiList = [];
            currentFilteredPoiList = [];
            selectedPois = [];
            displayedPoiCount = 0;
            updatePoiCount(0, 0);
            if (loadMoreBtn) loadMoreBtn.style.display = 'none';
            if (calculateSelectedRouteBtn) calculateSelectedRouteBtn.style.display = 'none';
            clearRouteLayer();
        }

        function clearRouteLayer() {
            if (routeLayer && map && map.hasLayer(routeLayer)) {
                map.removeLayer(routeLayer);
            }
            routeLayer = null;
             if (exportGpxBtn) exportGpxBtn.style.display = 'none';
        }

    </script>
</body>
</html>