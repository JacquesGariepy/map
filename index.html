
<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Planificateur d'Itinéraire Intelligent & Configurable</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin=""/>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin=""></script>

    <style>
        /* Styles améliorés */
        html, body { height: 100%; margin: 0; padding: 0; font-family: sans-serif; }
        #container { display: flex; height: 100%; }
        #sidebar { width: 400px; padding: 15px; box-sizing: border-box; background-color: #f8f8f8; overflow-y: auto; display: flex; flex-direction: column; border-right: 1px solid #ddd; }
        #map { flex-grow: 1; height: 100%; background-color: #eee; }
        label, input, select, button, textarea { display: block; margin-bottom: 10px; width: 100%; box-sizing: border-box; font-size: 0.95em; }
        textarea { min-height: 80px; resize: vertical; }
        button { padding: 10px 15px; border: none; cursor: pointer; border-radius: 4px; font-size: 1em; transition: background-color 0.2s; }
        button:disabled { background-color: #ccc !important; color: #666 !important; cursor: not-allowed; }
        #planRouteBtn { background-color: #007bff; color: white; }
        #planRouteBtn:hover:not(:disabled) { background-color: #0056b3; }
        #calculateSelectedRouteBtn { background-color: #28a745; color: white; margin-top: 10px; }
        #calculateSelectedRouteBtn:hover:not(:disabled) { background-color: #218838; }
        #poiPanel, #resultsPanel { border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px; }
        #poiFilters label { display: inline-block; margin-right: 10px; font-size: 0.9em; cursor: pointer; }
        #poiFilters input[type="checkbox"] { width: auto; margin-right: 3px; vertical-align: middle; }
        #poiList { max-height: 300px; overflow-y: auto; border: 1px solid #eee; margin-top: 5px; padding: 5px; background-color: #fff; }
        .poi-item { margin-bottom: 5px; cursor: pointer; padding: 6px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.9em; background-color: #fff; transition: background-color 0.1s; }
        .poi-item:hover { background-color: #e9e9e9; }
        .poi-item.selected { background-color: #d4edda; border-color: #28a745; font-weight: bold; }
        #loadMoreBtn { background-color: #6c757d; color: white; font-size: 0.9em; padding: 5px 10px; margin-top: 5px; }
        #loadMoreBtn:hover:not(:disabled) { background-color: #5a6268; }
        #showPoiToggle { margin-top: 10px; }
        #showPoiToggle label { font-size: 0.9em; cursor: pointer; }
        #showPoiToggle input { width: auto; vertical-align: middle; margin-right: 3px;}
        #routeInstructions { margin-top: 10px; }
        #routeInstructions h4 { margin-bottom: 5px;}
        #routeInstructions ol { padding-left: 20px; font-size: 0.9em; margin: 0; }
        #routeInstructions li { margin-bottom: 5px; }
        .error { color: #dc3545; font-weight: bold; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 5px; border-radius: 3px; margin-top: 5px;}
        .loading { font-style: italic; color: #6c757d; }
        .success { color: #28a745; font-weight: bold; }
        .info { color: #0056b3; }
        /* Attribution OSM */
        .leaflet-container { font-size: 12px; }
        /* Style pour Marker Cluster */
        .marker-cluster-small { background-color: rgba(181, 226, 140, 0.6); }
        .marker-cluster-small div { background-color: rgba(110, 204, 57, 0.6); }
        .marker-cluster-medium { background-color: rgba(241, 211, 87, 0.6); }
        .marker-cluster-medium div { background-color: rgba(240, 194, 12, 0.6); }
        .marker-cluster-large { background-color: rgba(253, 156, 115, 0.6); }
        .marker-cluster-large div { background-color: rgba(241, 128, 23, 0.6); }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h3>Planificateur d'Itinéraire IA</h3>

            <label for="start">Départ :</label>
            <input type="text" id="start" placeholder="Adresse de départ">

            <label for="end">Arrivée :</label>
            <input type="text" id="end" placeholder="Adresse d'arrivée">

            <label for="interests">Décrivez vos intérêts pour ce voyage :</label>
            <textarea id="interests" placeholder="Ex: Paysages magnifiques, nourriture du terroir, éviter autoroutes..."></textarea>

            <label for="profile">Profil de déplacement :</label>
            <select id="profile">
                <option value="driving-car" selected>Voiture</option>
                <option value="driving-hgv">Camion / Poids Lourd</option>
                <option value="cycling-regular">Vélo</option>
                <option value="foot-walking">Marche</option>
            </select>

            <label for="routePref">Préférence d'itinéraire (Voiture/Camion) :</label>
            <select id="routePref">
                <option value="FASTEST" selected>Le plus rapide</option>
                <option value="SHORTEST">Le plus court</option>
                <option value="AVOID_HIGHWAYS">Éviter les autoroutes</option>
                <option value="AVOID_TOLLS">Éviter les péages</option>
            </select>

            <button id="planRouteBtn">1. Trouver POI & Planifier</button>

            <div id="poiPanel">
                <h4>Points d'intérêt <span id="poiCount"></span></h4>
                <div id="poiFilters">
                    <label title="Points de vue, panoramas, paysages"><input type="checkbox" class="poi-filter" value="viewpoint,panorama,paysage" checked> Vues</label>
                    <label title="Parcs, jardins, réserves naturelles"><input type="checkbox" class="poi-filter" value="park,parc,garden,jardin,reserve,réserve" checked> Parcs/Réserves</label>
                    <label title="Magasins fermiers, marchés, produits locaux"><input type="checkbox" class="poi-filter" value="farm,ferme,market,marché,local,terroir,produit" checked> Terroir/Marchés</label>
                    <label title="Observation oiseaux, refuges"><input type="checkbox" class="poi-filter" value="bird,oiseau,hide,observatoire" checked> Oiseaux</label>
                    <label title="Sites historiques, châteaux, ruines"><input type="checkbox" class="poi-filter" value="historic,castle,château,ruin,ruine,monument" checked> Historique</label>
                    <label title="Lacs, rivières, plages, cascades"><input type="checkbox" class="poi-filter" value="water,beach,river,lake,waterfall,eau,plage,rivière,lac,cascade" checked> Eau/Plages</label>
                </div>
                 <div id="showPoiToggle">
                    <label><input type="checkbox" id="togglePoiLayer" checked> Afficher POI sur la carte</label>
                </div>
                <div id="poiList" class="loading">En attente...</div>
                <button id="loadMoreBtn" style="display: none;">Afficher plus de POI</button>
            </div>

             <button id="calculateSelectedRouteBtn" style="display: none;">2. Calculer l'itinéraire via POI sélectionnés</button>

            <div id="resultsPanel">
                <h4>Itinéraire et Résumé</h4>
                <div id="routeSummary" class="loading">En attente...</div>
                <div id="routeInstructions"></div>
            </div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        // --- Configuration ---
        const ORS_API_KEY = 'VOTRE_KEY'; // REMPLACEZ !
        const GEMINI_API_KEY = 'VOTRE_KEY'; // REMPLACEZ !
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
        const BOUNDING_BOX_MARGIN = 0.15; // Marge pour chercher POI (0.1 degré ~ 11km)
        const POI_LIST_LIMIT = 30; // Nb POI affichés par page dans la liste
        const MAP_DEFAULT_CENTER = [46.8139, -71.2080]; // Québec
        const MAP_DEFAULT_ZOOM = 10;
        const OVERPASS_TIMEOUT = 35; // Timeout pour Overpass en secondes
        const OVERPASS_API_ENDPOINT = 'https://overpass-api.de/api/interpreter'; // Endpoint Overpass
        // ---------------------

        // --- Variables Globales ---
        let map;
        let routeLayer = null;
        let fullPoiList = [];
        let displayedPoiCount = 0;
        let selectedPois = [];
        let poiMarkerClusterGroup = null;
        let currentFilteredPoiList = []; // Liste filtrée actuelle pour la pagination

        // Initialisation Leaflet & MarkerCluster
        try {
            map = L.map('map').setView(MAP_DEFAULT_CENTER, MAP_DEFAULT_ZOOM);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors'
            }).addTo(map);
            poiMarkerClusterGroup = L.markerClusterGroup({
                 chunkedLoading: true, // Améliore perf pour bcp de marqueurs
                 maxClusterRadius: 60  // Ajuster rayon de clustering
            });
            map.addLayer(poiMarkerClusterGroup); // Ajouter le groupe vide initialement
        } catch (e) {
             console.error("Erreur initialisation Leaflet:", e);
             alert("Erreur critique: Impossible d'initialiser la carte Leaflet.");
        }

        // --- DOM Elements ---
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');
        const interestsInput = document.getElementById('interests');
        const profileSelect = document.getElementById('profile');
        const routePrefSelect = document.getElementById('routePref');
        const planBtn = document.getElementById('planRouteBtn');
        const calculateSelectedRouteBtn = document.getElementById('calculateSelectedRouteBtn');
        const poiPanel = document.getElementById('poiPanel');
        const poiListDiv = document.getElementById('poiList');
        const poiCountSpan = document.getElementById('poiCount');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        const poiFilterCheckboxes = document.querySelectorAll('.poi-filter');
        const togglePoiLayerCheckbox = document.getElementById('togglePoiLayer');
        const summaryDiv = document.getElementById('routeSummary');
        const instructionsDiv = document.getElementById('routeInstructions');

        // --- Event Listeners ---
        if (planBtn) planBtn.addEventListener('click', handlePlanning);
        if (calculateSelectedRouteBtn) calculateSelectedRouteBtn.addEventListener('click', handleRouteCalculationFinal);
        if (loadMoreBtn) loadMoreBtn.addEventListener('click', () => displayMorePois()); // Appelle sans argument pour utiliser la liste filtrée courante
        if (togglePoiLayerCheckbox) togglePoiLayerCheckbox.addEventListener('change', togglePoiLayerVisibility);
        poiFilterCheckboxes.forEach(checkbox => checkbox.addEventListener('change', applyPoiFilters));

        // --- Fonctions API (Implémentations complètes) ---
         /**
         * Étape 1: Déclenchée par le bouton "Trouver POI & Planifier".
         * Gère la récupération des POI via IA et Overpass, puis affiche les POI.
         */
         async function handlePlanning() {
            clearPreviousResults();
            const startAddress = startInput.value;
            const endAddress = endInput.value;
            const interestsText = interestsInput.value;

            // Validations
            if (!startAddress || !endAddress || !interestsText) {
                summaryDiv.innerHTML = '<p class="error">Veuillez remplir Départ, Arrivée et vos Intérêts.</p>';
                return;
            }
            if (ORS_API_KEY.startsWith('VOTRE_') || GEMINI_API_KEY.startsWith('VOTRE_')) {
                summaryDiv.innerHTML = '<p class="error">ERREUR: Configurez vos clés API ORS et Gemini.</p>';
                return;
            }

            // Désactiver boutons pendant le traitement
            setButtonsDisabled(true);
            summaryDiv.innerHTML = '<p class="loading info">1/4 Calcul de la zone de recherche...</p>';
            poiListDiv.innerHTML = '<p class="loading">Calcul de la zone...</p>';
            poiCountSpan.textContent = '';

            try {
                // 1. Calculer Bounding Box
                const boundingBox = await getBoundingBox(startAddress, endAddress);
                if (!boundingBox) return; // Arrêt si erreur géocodage

                summaryDiv.innerHTML = '<p class="loading info">2/4 Génération requête POI par IA...</p>';
                // 2. Générer la requête Overpass QL
                const overpassQueryString = await generateOverpassQueryFromAI(interestsText, boundingBox);

                summaryDiv.innerHTML = '<p class="loading info">3/4 Recherche POI via Overpass (peut être long)...</p>';
                poiListDiv.innerHTML = '<p class="loading">Exécution requête Overpass...</p>';
                // 3. Exécuter la requête Overpass
                fullPoiList = await fetchPoisFromOverpass(overpassQueryString); // Stocker dans la liste globale

                summaryDiv.innerHTML = `<p class="success">4/4 Recherche terminée: ${fullPoiList.length} POI trouvés potentiellement pertinents.</p>`;
                poiCountSpan.textContent = `(${fullPoiList.length} total)`;

                // 4. Afficher les POI (avec filtres, limite, cluster)
                applyPoiFilters(); // Applique les filtres initiaux et affiche les POI

                // Afficher le bouton de calcul final si des POI ont été trouvés (même s'ils sont filtrés)
                if (fullPoiList.length > 0) {
                    calculateSelectedRouteBtn.style.display = 'block';
                } else {
                     poiListDiv.innerHTML = '<p class="info">Aucun POI trouvé pour ces critères/zone.</p>';
                     summaryDiv.innerHTML += '<br><p class="info">Planification arrêtée : Aucun POI trouvé.</p>';
                }

            } catch (error) {
                console.error("Erreur globale handlePlanning:", error);
                summaryDiv.innerHTML = `<p class="error">ERREUR ÉTAPE 1: ${error.message || 'Erreur inattendue.'}</p>`;
                poiListDiv.innerHTML = '<p class="error">Erreur.</p>';
            } finally {
                setButtonsDisabled(false); // Réactiver le bouton principal
                 // Ne pas réactiver calculateSelectedRouteBtn ici, il est géré séparément
            }
        }

        /**
         * Étape 2: Déclenchée par le bouton "Calculer l'itinéraire via POI sélectionnés".
         * Calcule et affiche l'itinéraire final et le résumé IA.
         */
         async function handleRouteCalculationFinal() {
             if (selectedPois.length === 0) {
                alert("Veuillez sélectionner au moins un point d'intérêt avant de calculer l'itinéraire.");
                return;
            }

            setButtonsDisabled(true); // Désactiver les deux boutons
            summaryDiv.innerHTML = `<p class="loading info">Calcul itinéraire via ${selectedPois.length} POI...</p>`;
            instructionsDiv.innerHTML = ''; // Nettoyer anciennes instructions

            try {
                const startAddress = startInput.value;
                const endAddress = endInput.value;
                const profile = profileSelect.value;
                const routePrefValue = routePrefSelect.value; // Lire la préférence ici
                const interestsText = interestsInput.value; // Pour le résumé

                // 5. Calculer l'itinéraire multi-points ORS
                const routeData = await getRouteFromOrs(startAddress, endAddress, selectedPois, profile, routePrefValue); // Passer la préférence

                summaryDiv.innerHTML = '<p class="loading info">Génération résumé IA...</p>';
                // 6. Générer résumé narratif IA
                const narrativeSummary = await getAiRouteSummary(interestsText, routeData);
                summaryDiv.innerHTML = narrativeSummary; // Remplacer le loading par le résumé

                summaryDiv.innerHTML += '<p class="loading info">Affichage itinéraire...</p>';
                // 7. Afficher l'itinéraire et les instructions
                displayRouteAndInstructions(routeData);
                summaryDiv.innerHTML += '<br><p class="success">Itinéraire calculé et affiché !</p>'; // Message de succès final

            } catch (error) {
                console.error("Erreur handleRouteCalculationFinal:", error);
                summaryDiv.innerHTML = `<p class="error">ERREUR ÉTAPE 2: ${error.message || 'Erreur calcul itinéraire final.'}</p>`;
            } finally {
                setButtonsDisabled(false); // Réactiver les deux boutons
            }
        }
        /**
         * Géocode une adresse en coordonnées [longitude, latitude] via l'API ORS Geocode.
         * @param {string} address - L'adresse à géocoder.
         * @returns {Promise<Array<number>|null>} Une promesse résolue avec [lng, lat] ou null en cas d'erreur.
         */
        async function getOrsCoordinates(address) {
            if (!address) return null; // Éviter requête inutile
            const url = `https://api.openrouteservice.org/geocode/search?api_key=${ORS_API_KEY}&text=${encodeURIComponent(address)}&size=1&boundary.country=CA`; // Limiter au Canada ?
            try {
                const response = await fetch(url);
                if (!response.ok) {
                     let errorMsg = `Erreur Géocodage ORS (${response.status}) pour "${address}"`;
                     try { errorMsg += `: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){}
                     throw new Error(errorMsg);
                 }
                const data = await response.json();
                if (!data.features || data.features.length === 0) {
                    throw new Error(`Adresse non trouvée par ORS: "${address}"`);
                }
                return data.features[0].geometry.coordinates; // [lng, lat]
            } catch (error) {
                console.error("Erreur Géocodage ORS:", error);
                summaryDiv.innerHTML = `<p class="error">Erreur Géocodage: ${error.message}. Vérifiez l'adresse.</p>`; // Afficher l'erreur
                // Relancer l'erreur pour arrêter le processus appelant si nécessaire
                throw error;
            }
        }

        /**
         * Calcule le bounding box englobant le départ et l'arrivée avec une marge.
         * @param {string} startAddress - Adresse de départ.
         * @param {string} endAddress - Adresse d'arrivée.
         * @returns {Promise<object|null>} Objet {south, west, north, east} ou null si erreur géocodage.
         */
        async function getBoundingBox(startAddress, endAddress) {
            console.log("Calcul du Bounding Box pour:", startAddress, "->", endAddress);
            try {
                const startCoords = await getOrsCoordinates(startAddress);
                const endCoords = await getOrsCoordinates(endAddress);

                // Si le géocodage a échoué, l'erreur est déjà gérée et l'exception est propagée
                if (!startCoords || !endCoords) return null; // Devrait être déjà stoppé par l'exception

                console.log("Coords Départ:", startCoords, "Coords Arrivée:", endCoords);

                const lat1 = startCoords[1]; const lon1 = startCoords[0];
                const lat2 = endCoords[1];   const lon2 = endCoords[0];

                // Gérer le cas où départ et arrivée sont identiques ou très proches
                if (Math.abs(lat1 - lat2) < 0.001 && Math.abs(lon1 - lon2) < 0.001) {
                     console.log("Points départ/arrivée très proches, utilisation d'une boîte par défaut autour du point.");
                     return {
                         south: lat1 - BOUNDING_BOX_MARGIN,
                         west:  lon1 - BOUNDING_BOX_MARGIN,
                         north: lat1 + BOUNDING_BOX_MARGIN,
                         east:  lon1 + BOUNDING_BOX_MARGIN
                     };
                }

                const minLat = Math.min(lat1, lat2);
                const maxLat = Math.max(lat1, lat2);
                const minLon = Math.min(lon1, lon2);
                const maxLon = Math.max(lon1, lon2);

                // Ajouter la marge
                const south = minLat - BOUNDING_BOX_MARGIN;
                const west = minLon - BOUNDING_BOX_MARGIN;
                const north = maxLat + BOUNDING_BOX_MARGIN;
                const east = maxLon + BOUNDING_BOX_MARGIN;

                const calculatedBbox = { south, west, north, east };
                console.log("Bounding Box Calculé:", calculatedBbox);
                return calculatedBbox;

            } catch (error) {
                 // Erreur déjà loggée par getOrsCoordinates ou ici
                 console.error("Erreur finale lors du calcul du Bounding Box:", error);
                 summaryDiv.innerHTML = `<p class="error">Erreur définition zone: ${error.message}</p>`;
                 return null; // Indiquer l'échec
            }
        }

        /**
         * Demande à l'IA (Gemini) de générer une requête Overpass QL basée sur les intérêts et la zone.
         * @param {string} interests - Description textuelle des intérêts.
         * @param {object} boundingBox - Objet {south, west, north, east}.
         * @returns {Promise<string>} La requête Overpass QL générée.
         */
        async function generateOverpassQueryFromAI(interests, boundingBox) {
             if (!boundingBox || typeof boundingBox.south !== 'number') {
                throw new Error("Bounding Box invalide fourni pour la génération de requête IA.");
            }
            // Formatage sécurisé pour éviter les erreurs de précision ?
            const bboxString = `(${boundingBox.south.toFixed(6)},${boundingBox.west.toFixed(6)},${boundingBox.north.toFixed(6)},${boundingBox.east.toFixed(6)})`;

            const prompt = `
                Tu es un expert mondial en données OpenStreetMap (OSM) et dans le langage de requête Overpass QL.
                L'utilisateur souhaite planifier un itinéraire et a décrit ses intérêts.
                Ta tâche est de générer une requête Overpass QL complète et optimisée pour trouver des points d'intérêt (POI) pertinents (nodes, ways, relations) dans une zone géographique donnée.

                Intérêts de l'utilisateur: "${interests}"

                Zone géographique (bounding box au format south, west, north, east): ${bboxString}

                Instructions pour la requête Overpass QL:
                1.  Utilise le format de sortie '[out:json]' et un timeout raisonnable '[timeout:${OVERPASS_TIMEOUT}]'.
                2.  Combine plusieurs types de POI pertinents basés sur les intérêts de l'utilisateur en utilisant la logique OR (union). Par exemple, pour "paysages et oiseaux", cherche les points de vue (tourism=viewpoint), les parcs (leisure=park), les réserves naturelles (leisure=nature_reserve), les sommets (natural=peak), les lacs/rivières (natural=water), les zones ornithologiques (leisure=bird_hide), peut-être des routes panoramiques (highway=road + scenic=yes, mais attention c'est rare). Pour "nourriture du terroir", cherche les marchés (amenity=marketplace), les magasins à la ferme (shop=farm), les producteurs locaux si possible (shop=food + product=*, ou via nom). Pour "villages pittoresques", cherche les lieux marqués comme place=village ou place=hamlet et peut-être avec des éléments historic=*.
                3.  Applique le bounding box ${bboxString} correctement à chaque clause de recherche principale DANS l'union (ex: '( node[tag]${bboxString}; way[tag]${bboxString}; );' ).
                4.  Utilise 'out center;' pour obtenir un point central pour les ways et relations afin d'avoir des coordonnées pour tous les résultats.
                5.  Essaie de limiter la complexité si possible pour éviter les timeouts Overpass, mais sois assez large pour trouver des choses intéressantes. NE PAS utiliser de requêtes récursives complexes (comme > ou <) si non essentiel.
                6.  Ne génère QUE la requête Overpass QL sous forme de chaîne de caractères brute. N'ajoute AUCUN commentaire dans le code QL, aucune explication avant ou après, et aucun formatage markdown (comme \`\`\`).

                Requête Overpass QL générée:
            `;

            try {
                console.log("Prompt Gemini (Query Gen) avec BBox:", bboxString);
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.3, topP: 0.95 } // Ajuster pour + de cohérence
                         })
                });
                if (!response.ok) {
                    let errorMsg = `Erreur API Gemini (${response.status}) Query Gen.`;
                     try { errorMsg += ` Détail: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){}
                     throw new Error(errorMsg);
                 }
                const data = await response.json();

                 if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    console.error("Réponse Gemini (Query Gen) inattendue:", JSON.stringify(data));
                    throw new Error("Structure de réponse IA inattendue (Query Gen).");
                 }
                const generatedQuery = data.candidates[0].content.parts[0].text;

                if (!generatedQuery.includes('[out:json]')) {
                    console.error("Requête générée invalide ou vide:", generatedQuery);
                    throw new Error("L'IA n'a pas généré une requête Overpass QL valide (manque [out:json]).");
                }
                const cleanedQuery = generatedQuery.replace(/```(ql|overpass)?\s*|\s*```/g, '').trim();
                console.log("Requête Overpass générée par IA (nettoyée):", cleanedQuery);
                return cleanedQuery;

            } catch (error) {
                console.error("Erreur appel IA (Query Gen):", error);
                // Renvoyer l'erreur pour l'afficher dans l'UI
                throw new Error(`Génération requête IA échouée: ${error.message}`);
            }
        }

        /**
         * Exécute la requête Overpass QL fournie et retourne les POI.
         * @param {string} generatedQueryString - La requête Overpass QL complète.
         * @returns {Promise<Array<object>>} Liste des POI {id, name, coordinates, tags}.
         */
        async function fetchPoisFromOverpass(generatedQueryString) {
            if (!generatedQueryString) {
                console.warn("Aucune requête Overpass fournie à exécuter.");
                return [];
            }
            console.log("Exécution de la requête Overpass générée...");

            try {
                // Utiliser fetch avec un timeout (via AbortController) pour éviter les blocages indéfinis
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), (OVERPASS_TIMEOUT + 5) * 1000); // Timeout client un peu plus long que celui serveur

                const response = await fetch(OVERPASS_API_ENDPOINT, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(generatedQueryString)}`,
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },
                    signal: controller.signal // Lier l'AbortController
                });

                clearTimeout(timeoutId); // Annuler le timeout client si la réponse arrive

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Erreur brute d'Overpass API (${response.status}):`, errorText);
                    const errorMatch = errorText.match(/<p>Error: (.*?)<\/p>/) || errorText.match(/Error:(.*)/);
                    const simpleError = errorMatch ? errorMatch[1].trim() : `Statut ${response.status}.`;
                    // Distinguer timeout potentiel
                    if (response.status === 400 && simpleError.includes("timeout")) {
                        throw new Error(`Erreur API Overpass: Timeout (${OVERPASS_TIMEOUT}s). La requête IA était trop complexe.`);
                    } else if (response.status === 429) {
                        throw new Error(`Erreur API Overpass: Trop de requêtes (Rate Limit). Réessayez plus tard.`);
                    }
                     throw new Error(`Erreur API Overpass: ${simpleError}. Vérifiez la requête IA.`);
                }

                const data = await response.json();

                // Mapper les résultats
                const pois = data.elements.map(el => {
                    let name = el.tags?.name || el.tags?.['official_name'] || el.tags?.['alt_name'];
                    if (!name) {
                        // Essayer de trouver un tag descriptif principal
                        const primaryTagEntry = Object.entries(el.tags || {}).find(([k, v]) =>
                            !['name', 'official_name', 'alt_name', 'source', 'note', 'fixme', 'wikidata', 'wikipedia', 'created_by', 'addr:housenumber', 'addr:street', 'addr:city', 'addr:postcode', 'opening_hours', 'phone', 'website'].includes(k) && v !== 'no' && v!== 'yes' // Exclure plus de tags non descriptifs et valeurs simples oui/non
                        );
                        if (primaryTagEntry) {
                            const [key, value] = primaryTagEntry;
                            let typeName = value.replace(/_/g, ' '); // Remplacer underscores par espaces

                            // Améliorer la lisibilité pour les cas courants (vous pouvez en ajouter d'autres)
                            const typeMap = {
                                'tourism=viewpoint': 'Point de vue',
                                'leisure=park': 'Parc',
                                'leisure=nature_reserve': 'Réserve naturelle',
                                'shop=farm': 'Magasin fermier',
                                'amenity=marketplace': 'Marché',
                                'natural=water': 'Plan d\'eau',
                                'natural=peak': 'Sommet',
                                'historic=ruins': 'Ruines',
                                'historic=castle': 'Château',
                                'leisure=bird_hide': 'Observatoire oiseaux'
                                // Ajoutez d'autres paires 'key=value': 'Nom Lisible' ici
                            };
                            const tagString = `<span class="math-inline">\{key\}\=</span>{value}`;
                            typeName = typeMap[tagString] || typeName.charAt(0).toUpperCase() + typeName.slice(1); // Utiliser le nom lisible ou capitaliser la valeur du tag

                            name = `${typeName} (sans nom)`;
                        } else {
                            name = `[POI sans nom #${el.id}]`; // Fallback ultime
                        }
                    }
                    return {
                        id: el.id,
                        name: name,
                        coordinates: [el.lon ?? el.center?.lon, el.lat ?? el.center?.lat],
                        tags: el.tags
                    };
                }).filter(poi => poi.coordinates[0] && poi.coordinates[1]);

                console.log(`Nombre de POIs trouvés par Overpass: ${pois.length}`);
                // Optionnel: Filtrer les doublons par ID (Overpass peut retourner node+way pour le même objet)
                const uniquePois = Array.from(new Map(pois.map(p => [p.id, p])).values());
                 if (uniquePois.length < pois.length) {
                     console.log(`Filtré ${pois.length - uniquePois.length} doublons de POI par ID.`);
                 }
                return uniquePois;

            } catch (error) {
                console.error("Erreur lors de l'exécution/traitement requête Overpass:", error);
                 if (error.name === 'AbortError') {
                    throw new Error(`Erreur API Overpass: Timeout client dépassé (${OVERPASS_TIMEOUT + 5}s).`);
                 }
                // Renvoyer l'erreur pour l'afficher
                throw new Error(`Erreur recherche POI: ${error.message}`);
            }
        }

        /**
         * Calcule l'itinéraire via ORS en passant par les waypoints sélectionnés.
         * @param {string} startAddress - Adresse départ.
         * @param {string} endAddress - Adresse arrivée.
         * @param {Array<object>} waypoints - Liste des POI sélectionnés { coordinates: [lng, lat] }.
         * @param {string} profile - Profil ORS (ex: 'driving-car').
         * @param {string} routePreference - Préférence (FASTEST, SHORTEST, AVOID_HIGHWAYS, AVOID_TOLLS).
         * @returns {Promise<object>} Données GeoJSON de l'itinéraire.
         */
        async function getRouteFromOrs(startAddress, endAddress, waypoints, profile, routePreference) {
            summaryDiv.innerHTML += '<p class="loading">...géocodage départ/arrivée...</p>';
            let startCoords, endCoords;
            try {
                startCoords = await getOrsCoordinates(startAddress);
                endCoords = await getOrsCoordinates(endAddress);
            } catch (error) {
                 // L'erreur est déjà affichée par getOrsCoordinates, on la relance pour arrêter
                 throw error;
            }
            if (!startCoords || !endCoords) throw new Error("Géocodage du départ ou de l'arrivée échoué (coords null).");

            const allCoordinates = [startCoords, ...waypoints.map(poi => poi.coordinates), endCoords];

            let options = {}; // Utiliser un objet pour les options
            let preference = 'fastest'; // Défaut

            if (profile === 'driving-car' || profile === 'driving-hgv') {
                 const avoidFeatures = [];
                 if (routePreference === 'AVOID_HIGHWAYS') {
                     avoidFeatures.push('highways');
                     preference = 'shortest'; // Souvent mieux sans autoroutes
                 }
                 if (routePreference === 'AVOID_TOLLS') {
                     avoidFeatures.push('tollways');
                 }
                 if (avoidFeatures.length > 0) {
                     options.avoid_features = avoidFeatures;
                 }
                 if (routePreference === 'SHORTEST') {
                     preference = 'shortest';
                 }
                 // Pour HGV, on pourrait ajouter des options de dimensions ici si on les avait
                 if (profile === 'driving-hgv') {
                      options.vehicle_type = 'hgv'; // Spécifier explicitement? Doc ORS
                      // Ex: options.weight = 15000; options.height = 4; options.length = 12;
                      preference = 'shortest'; // Préférer shortest pour HGV par défaut?
                 }
            }
            // Gérer d'autres profils si nécessaire

            const url = `https://api.openrouteservice.org/v2/directions/${profile}/geojson`;
            const body = {
                coordinates: allCoordinates,
                language: 'fr',
                instructions: true,
                instructions_format: "text",
                // Ne passer 'options' que s'il contient quelque chose
                ...(Object.keys(options).length > 0 && { options: options }),
                preference: preference
            };
            summaryDiv.innerHTML += '<p class="loading">...appel API routage ORS...</p>';
            console.log("Requête ORS:", JSON.stringify(body)); // Log pour débogage

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    body: JSON.stringify(body),
                    headers: {
                        'Authorization': ORS_API_KEY,
                        'Content-Type': 'application/json; charset=utf-8',
                        'Accept': 'application/json, application/geo+json'
                    }
                });
                if (!response.ok) {
                    let errorMsg = `Erreur Routage ORS (${response.status})`;
                     try { errorMsg += `: ${(await response.json())?.error?.message || response.statusText}`; } catch(e){}
                     if (response.status === 404 && errorMsg.includes("Point")) errorMsg += ". Un POI est peut-être inaccessible ?";
                     else if (response.status === 400 && errorMsg.includes("maximum distance")) errorMsg += ". Itinéraire trop long ?";
                    throw new Error(errorMsg);
                }
                return await response.json();
            } catch (error) {
                console.error("Erreur Routage ORS:", error);
                throw new Error(`Calcul itinéraire ORS échoué: ${error.message}`);
            }
        }

        /**
         * Demande à l'IA (Gemini) de générer un résumé narratif du voyage.
         * @param {string} interests - Intérêts de l'utilisateur.
         * @param {object} routeData - Données GeoJSON de l'itinéraire ORS.
         * @returns {Promise<string>} Résumé textuel généré.
         */
        async function getAiRouteSummary(interests, routeData) {
             if (!routeData) return "<p class='error'>Données d'itinéraire manquantes pour générer le résumé.</p>";
            try {
                 const segments = routeData?.features?.[0]?.properties?.segments || [];
                 const summary = routeData?.features?.[0]?.properties?.summary;
                 const distanceKm = summary ? (summary.distance / 1000).toFixed(1) : '?';
                 const durationMin = summary ? Math.round(summary.duration / 60) : '?';
                 const waypointNames = selectedPois.map(p => p.name).join(', ') || 'points d\'intérêt sélectionnés';
                 // Extraire une instruction clé par segment
                 const segmentHighlights = segments.map((seg, index) => {
                    let highlight = `Étape ${index+1}`;
                    if (seg.steps && seg.steps.length > 0) {
                        // Cherche une instruction significative (pas juste 'continue')
                        const significantStep = seg.steps.find(s => !s.instruction.toLowerCase().startsWith("continuez")) || seg.steps[0];
                        if (significantStep) highlight += `: ${significantStep.instruction.substring(0,50)}...`;
                    }
                    return highlight;
                 }).join('; ');

                 const prompt = `
                    Tu es un assistant de voyage enthousiaste. Rédige un court paragraphe (environ 4-6 phrases) décrivant le voyage planifié de manière attrayante et personnalisée, en te basant sur les intérêts de l'utilisateur et les détails de l'itinéraire. Mets en valeur comment le trajet semble correspondre à ses attentes.

                    Intérêts de l'utilisateur: "${interests}"
                    Itinéraire calculé: Passe par ${waypointNames}. Distance totale: ${distanceKm} km, Durée estimée: ${durationMin} minutes. Aperçu des étapes: ${segmentHighlights.substring(0, 250)}...

                    Paragraphe narratif (en français, ton direct et engageant):
                 `;

                 const response = await fetch(GEMINI_API_URL, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.7, topP: 0.9 }
                         })
                 });
                  if (!response.ok) throw new Error(`Erreur API Gemini (${response.status}) pour le résumé.`);
                 const data = await response.json();

                  if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    console.error("Réponse Gemini (Résumé) inattendue:", data);
                    return "<p class='error'>Erreur: Structure de réponse IA inattendue pour le résumé.</p>";
                 }
                 const summaryText = data.candidates[0].content.parts[0].text;
                 // Nettoyage simple
                 return summaryText.replace(/<p>/gi, '').replace(/<\/p>/gi, '<br>');

            } catch (error) {
                console.error("Erreur appel IA (Résumé):", error);
                return `<p class="error">Impossible de générer le résumé IA: ${error.message}</p>`;
            }
        }


        // --- Fonctions d'Affichage et d'Interaction (Implémentations complètes) ---

        /** Affiche les POI filtrés (liste + carte cluster). Gère pagination liste. */
        function displayPoisAndEnableSelection(poisToDisplay) {
            console.log(`Affichage des POI filtrés (max ${POI_LIST_LIMIT} dans la liste initialement)`);
            poiListDiv.innerHTML = '';
            poiMarkerClusterGroup.clearLayers();
            poiMarkers = [];
            // Ne pas réinitialiser selectedPois ici, l'utilisateur peut vouloir garder sa sélection entre filtrages
            displayedPoiCount = 0;

            currentFilteredPoiList = poisToDisplay; // Mémoriser la liste filtrée actuelle

            if (!currentFilteredPoiList || currentFilteredPoiList.length === 0) {
                if (fullPoiList.length > 0) {
                    poiListDiv.innerHTML = '<p class="info">Aucun POI ne correspond aux filtres actifs.</p>';
                } else {
                    poiListDiv.innerHTML = '<p class="info">Aucun POI trouvé par Overpass.</p>';
                }
                loadMoreBtn.style.display = 'none';
                updatePoiCount(0, 0);
                calculateSelectedRouteBtn.style.display = 'none'; // Cacher si aucun POI
                return;
            }

            // Afficher le premier lot et les marqueurs
            displayMorePois(); // Appelle sans argument pour utiliser currentFilteredPoiList

            // Assurer que la couche cluster est visible si la case est cochée
            if (togglePoiLayerCheckbox.checked && !map.hasLayer(poiMarkerClusterGroup)) {
                map.addLayer(poiMarkerClusterGroup);
            } else if (!togglePoiLayerCheckbox.checked && map.hasLayer(poiMarkerClusterGroup)) {
                 map.removeLayer(poiMarkerClusterGroup); // Cacher si décoché au départ
            }

             // Afficher le bouton de calcul final seulement si on a trouvé des POI (même s'ils sont tous filtrés initialement)
            calculateSelectedRouteBtn.style.display = 'block';
        }

        /** Ajoute le prochain lot de POI à la liste et crée tous les marqueurs pour le cluster. */
        function displayMorePois() {
            const sourceList = currentFilteredPoiList; // Utiliser la liste filtrée mémorisée
            const isInitialDisplay = (displayedPoiCount === 0);

            const startIndex = displayedPoiCount;
            const endIndex = Math.min(startIndex + POI_LIST_LIMIT, sourceList.length);

            console.log(`Affichage POIs ${startIndex} à ${endIndex-1} sur ${sourceList.length} filtrés.`);

            if (startIndex >= sourceList.length && !isInitialDisplay) {
                 console.log("Tous les POI filtrés sont déjà dans la liste.");
                 loadMoreBtn.style.display = 'none';
                 return;
            }

            // Préparer les éléments de liste et les marqueurs
            const listFragment = document.createDocumentFragment();
            const markersToAdd = [];

            for (let i = startIndex; i < endIndex; i++) {
                const poi = sourceList[i];
                // Ajouter à la liste latérale (fragment)
                const poiDiv = document.createElement('div');
                poiDiv.classList.add('poi-item');
                if (selectedPois.some(p => p.id === poi.id)) {
                    poiDiv.classList.add('selected');
                }
                poiDiv.textContent = poi.name || `POI #${poi.id}`;
                poiDiv.title = `ID: ${poi.id}\nTags: ${JSON.stringify(poi.tags, null, 1)}`; // Tooltip avec infos
                poiDiv.dataset.poiId = poi.id;
                poiDiv.dataset.coords = JSON.stringify(poi.coordinates);
                poiDiv.dataset.name = poi.name || `POI #${poi.id}`;
                poiDiv.addEventListener('click', togglePoiSelection);
                listFragment.appendChild(poiDiv);
            }
             // Ajouter tous les marqueurs de la liste filtrée au cluster lors du premier affichage seulement
             // pour éviter de recréer/dupliquer les marqueurs sur "Afficher plus"
             if (isInitialDisplay) {
                 sourceList.forEach(poi => {
                    try {
                        const marker = L.marker([poi.coordinates[1], poi.coordinates[0]])
                            .bindPopup(`<b>${poi.name || `POI #${poi.id}`}</b><br><small>ID: ${poi.id}</small>`);
                        marker.poiData = poi;
                        marker.on('click', (e) => {
                             const correspondingDiv = poiListDiv.querySelector(`.poi-item[data-poi-id="${e.target.poiData.id}"]`);
                             if (correspondingDiv) togglePoiSelection({ currentTarget: correspondingDiv });
                             // Ouvrir popup en plus?
                             // e.target.openPopup();
                         });
                        markersToAdd.push(marker); // Ajouter au tableau temporaire
                    } catch (e) {
                         console.error("Erreur création marqueur pour POI:", poi, e);
                    }
                 });
                 poiMarkerClusterGroup.addLayers(markersToAdd); // Ajout groupé plus performant
                 poiMarkers = markersToAdd; // Garder référence à tous les marqueurs créés
             }


            // Ajouter le fragment à la liste réelle du DOM
            poiListDiv.appendChild(listFragment);

            displayedPoiCount = endIndex;
            updatePoiCount(displayedPoiCount, sourceList.length);

            // Gérer le bouton "Afficher plus"
            loadMoreBtn.style.display = (displayedPoiCount < sourceList.length) ? 'block' : 'none';

             // Ajuster la vue aux POIs lors du premier affichage seulement
             if (isInitialDisplay && poiMarkers.length > 0) {
                 try {
                     // Donner la priorité au zoom sur les POI plutôt que sur la route calculée initialement
                     // const bounds = poiMarkerClusterGroup.getBounds();
                     // if (bounds.isValid()) { map.fitBounds(bounds.pad(0.1)); }
                 } catch (e) { console.warn("Impossible d'ajuster les limites aux POI.", e); }
             } else if (isInitialDisplay && sourceList.length === 0) {
                 // Si aucun POI après filtre, recentrer carte ?
                 // map.setView(MAP_DEFAULT_CENTER, MAP_DEFAULT_ZOOM);
             }
        }

        /** Met à jour le texte du compteur de POI */
        function updatePoiCount(displayed, totalFiltered) {
             poiCountSpan.textContent = `(${displayed} affichés / ${totalFiltered} filtrés / ${fullPoiList.length} total)`;
        }

        /** Bascule la sélection d'un POI */
        function togglePoiSelection(event) {
            if (!event || !event.currentTarget) return;
            const poiDiv = event.currentTarget;
            const poiId = poiDiv.dataset.poiId;
            // Retrouver les données complètes du POI depuis fullPoiList ou currentFilteredPoiList
             const poiDataFromList = currentFilteredPoiList.find(p => p.id == poiId) || fullPoiList.find(p => p.id == poiId);
             if (!poiDataFromList) {
                 console.error("Impossible de retrouver les données du POI cliqué:", poiId);
                 return;
             }
             // Utiliser une copie pour éviter modif accidentelle? Pour l'instant, ok.
             const poiData = poiDataFromList; // { id, name, coordinates, tags }

            const index = selectedPois.findIndex(p => p.id == poiId);
            if (index > -1) { // Désélectionner
                selectedPois.splice(index, 1);
                poiDiv.classList.remove('selected');
            } else { // Sélectionner
                selectedPois.push(poiData);
                poiDiv.classList.add('selected');
            }
            console.log(`${selectedPois.length} POIs sélectionnés:`, selectedPois.map(p=>p.name));
        }

        /** Affiche ou masque la couche de clusters de POI */
        function togglePoiLayerVisibility() {
            if (togglePoiLayerCheckbox.checked) {
                if (!map.hasLayer(poiMarkerClusterGroup)) {
                    map.addLayer(poiMarkerClusterGroup);
                    console.log("Couche POI affichée.");
                }
            } else {
                if (map.hasLayer(poiMarkerClusterGroup)) {
                    map.removeLayer(poiMarkerClusterGroup);
                    console.log("Couche POI masquée.");
                }
            }
        }

        /** Applique les filtres et réaffiche les POI */
        function applyPoiFilters() {
            console.log("Application des filtres POI...");
            currentFilteredPoiList = fullPoiList.filter(applySinglePoiFilter);
            // Réinitialiser l'affichage avec la liste filtrée
            displayPoisAndEnableSelection(currentFilteredPoiList);
        }

        /** Fonction de filtrage pour un seul POI basée sur les cases cochées */
        function applySinglePoiFilter(poi) {
            const checkedFilters = Array.from(poiFilterCheckboxes).filter(cb => cb.checked);
            if (checkedFilters.length === 0) return true; // Si rien coché, tout afficher

            const poiNameLower = (poi.name || '').toLowerCase();
            const poiTagsStringLower = JSON.stringify(poi.tags || {}).toLowerCase();

            for (const checkbox of checkedFilters) {
                const keywords = checkbox.value.split(',');
                for (const keyword of keywords) {
                    const keywordLower = keyword.toLowerCase().trim();
                    if (keywordLower && (poiNameLower.includes(keywordLower) || poiTagsStringLower.includes(`"${keywordLower}"`) || poiTagsStringLower.includes(`=${keywordLower}"`))) {
                        return true;
                    }
                }
            }
            return false; // Ne correspond à aucun filtre actif
        }

        /** Affiche l'itinéraire final et les instructions */
        function displayRouteAndInstructions(routeData) {
             if (routeLayer) map.removeLayer(routeLayer);
             const routeStyle = { color: "#0056b3", weight: 6, opacity: 0.8 }; // Bleu foncé
             try {
                 routeLayer = L.geoJSON(routeData, { style: routeStyle }).addTo(map);
                 map.fitBounds(routeLayer.getBounds().pad(0.1));
             } catch(e) {
                 console.error("Erreur lors de l'affichage de la route GeoJSON:", e);
                 instructionsDiv.innerHTML = "<p class='error'>Erreur lors de l'affichage de la route.</p>";
                 return;
             }

            const segments = routeData?.features?.[0]?.properties?.segments || [];
            if (segments.length > 0) {
                 instructionsDiv.innerHTML = '<h4>Instructions Détaillées :</h4><ol>';
                 segments.forEach((segment, segIndex) => {
                     const targetName = selectedPois[segIndex]?.name || (segIndex === segments.length - 1 ? 'Destination Finale' : `Waypoint ${segIndex + 1}`);
                     instructionsDiv.innerHTML += `<li style="margin-top: 5px;"><strong>Vers ${targetName}</strong> (~${(segment.distance/1000).toFixed(1)} km)</li>`;
                     (segment.steps || []).forEach(step => {
                         instructionsDiv.innerHTML += `<li style="margin-left: 15px; font-size: 0.95em;">${step.instruction} (${(step.distance / 1000).toFixed(1)} km)</li>`;
                     });
                 });
                 instructionsDiv.innerHTML += '</ol>';
            } else {
                 instructionsDiv.innerHTML = '<p class="info">Aucune instruction détaillée disponible.</p>';
            }
        }

        /** Nettoie les résultats précédents (carte et panneaux) */
        function clearPreviousResults() {
            console.log("Nettoyage des résultats précédents...");
            if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
            poiMarkerClusterGroup.clearLayers();
            poiMarkers = [];
            selectedPois = [];
            fullPoiList = [];
            currentFilteredPoiList = [];
            displayedPoiCount = 0;
            poiListDiv.innerHTML = '<p class="loading">Prêt.</p>';
            summaryDiv.innerHTML = '<p class="loading">Prêt.</p>';
            instructionsDiv.innerHTML = '';
            poiCountSpan.textContent = '';
            loadMoreBtn.style.display = 'none';
            calculateSelectedRouteBtn.style.display = 'none';
            if (!togglePoiLayerCheckbox.checked) {
                 togglePoiLayerCheckbox.checked = true;
                 if (!map.hasLayer(poiMarkerClusterGroup)) map.addLayer(poiMarkerClusterGroup);
            }
            setButtonsDisabled(false); // S'assurer que les boutons sont réactivés
        }

        /** Active/Désactive les boutons principaux */
        function setButtonsDisabled(disabled) {
             if(planBtn) planBtn.disabled = disabled;
             if(calculateSelectedRouteBtn) calculateSelectedRouteBtn.disabled = disabled;
             if(loadMoreBtn) loadMoreBtn.disabled = disabled; // Désactiver aussi "Afficher plus" pendant chargement
             // Désactiver aussi les filtres pendant le chargement ?
             poiFilterCheckboxes.forEach(cb => cb.disabled = disabled);
             togglePoiLayerCheckbox.disabled = disabled;
        }

    </script>
</body>
</html>